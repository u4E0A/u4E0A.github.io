[{"categories":["算法"],"content":"试题 算法训练 盾神与格子游戏 ","date":"2023-04-06","objectID":"/algo-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/:0:0","tags":["基础","SG","DP","算法"],"title":"算法 ALGO 835 盾神与格子游戏","uri":"/algo-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"题目 问题描述 在盾神很小很小还不会怎样编程的时候，他迷上了一款风靡一时的双人游戏！游戏双方在地上画n个格子，然后在最后一格放上一颗石头。每人每轮可以把石头向前移动1到3格，最后谁把石头移出第一格就赢了。盾神那时候很傻很天真，每次都是随便乱玩，结果每次都会输。。。 盾神今天回想起来，那时候的自己真是弱暴了！！！今天的盾神不仅一眼把这个游戏的必胜方法秒解，还提出了一个进化版：每人每轮不是把石头向前移动1到3格那么简单，而是有m种选择：第i种可以向前移动ai格。其他规则还是和以前一样。那么聪明的你，能告诉盾神，如果双方都采取最优策略，先手第一步该怎样做才可以保证必胜？ 输入格式 第一行为两个数n，m。 第二行m个数，表示ai。 输出格式 如果先手必败，输出“poor dun”，否则输出先手第一步应该向前移动多少格，如果有多种方案，选择移动距离最少的那个。 样例输入 6 3 1 10 100 样例输出 10 样例输入 6 3 1 2 3 样例输出 2 样例输入 6 3 1 1 1 样例输出 poor dun 数据规模和约定 对于20％的数据，ai为从1到m的连续整数。 对于另外30％的数据，n\u003c=20,m\u003c=3。 对于100％的数据，n\u003c=100000,m\u003c=100,0\u003cai\u003c=100000。 ","date":"2023-04-06","objectID":"/algo-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/:1:0","tags":["基础","SG","DP","算法"],"title":"算法 ALGO 835 盾神与格子游戏","uri":"/algo-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"题解 ","date":"2023-04-06","objectID":"/algo-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/:2:0","tags":["基础","SG","DP","算法"],"title":"算法 ALGO 835 盾神与格子游戏","uri":"/algo-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.StringTokenizer; public class Main { public static int[] choices; public static int[] sgArray; public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine()); int n = Integer.parseInt(stringTokenizer.nextToken()); int m = Integer.parseInt(stringTokenizer.nextToken()); stringTokenizer = new StringTokenizer(bufferedReader.readLine()); sgArray = new int[n + 1]; choices = new int[m]; for (int i = 0; i \u003c m; i++) { choices[i] = Integer.parseInt(stringTokenizer.nextToken()); } Arrays.sort(choices); sgArray[choices[0]] = choices[0]; for (int i = 1; i \u003c n + 1; i++) { for (int j = 0; j \u003c m; j++) { if (i - choices[j] \u003c 0 || sgArray[i - choices[j]] == 0) { sgArray[i] = 1; break; } } } for (int firstStep : choices) { if (n - firstStep \u003c 0 || sgArray[n - firstStep] == 0) { System.out.println(firstStep); return; } } System.out.println(\"poor dun\"); } } ","date":"2023-04-06","objectID":"/algo-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/:3:0","tags":["基础","SG","DP","算法"],"title":"算法 ALGO 835 盾神与格子游戏","uri":"/algo-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"试题 算法训练 最大最小公倍数 ","date":"2023-03-23","objectID":"/algo-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/:0:0","tags":["贪心","算法"],"title":"算法 ALGO 2 最大最小公倍数","uri":"/algo-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"题目 问题描述 已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。 输入格式 输入一个正整数N。 输出格式 输出一个整数，表示你找到的最小公倍数。 样例输入 9 样例输出 504 数据规模与约定 1 \u003c= N \u003c= 106。 ","date":"2023-03-23","objectID":"/algo-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/:1:0","tags":["贪心","算法"],"title":"算法 ALGO 2 最大最小公倍数","uri":"/algo-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"题解 该题考查的是贪心算法。首先考虑何种情况下可以构造一个比较大的最小公倍数，容易想到当三数互素或其最大公约数较小的时候最小公倍数较大。 考虑N、N-1、N-2，当N为奇数时，三者显然互素。因为三者的因数最大为N-(N-2)=2，而由于N和N-2均为奇数，故其最小公约数为1。 当N为偶数时，比较N*(N-1)*(N-2)/2和N*(N-1)*(N-3)，显然后者较大，但可能存在gcd(N,N-3)=3。 当N有因数3时，比较N*(N-1)*(N-3)/3和(N-1)*(N-2)*(N-3)，显然后者较大，即存在三种情况： N为奇数 out = (long) N * (N - 1) * (N - 2); N为偶数且被3整除 out = (long) (N - 1) * (N - 2) * (N - 3); N为偶数且不被3整除 out = (long) N * (N - 1) * (N - 3); ","date":"2023-03-23","objectID":"/algo-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/:2:0","tags":["贪心","算法"],"title":"算法 ALGO 2 最大最小公倍数","uri":"/algo-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bufferedReader.readLine()); long out = 0; if (N % 2 == 1) { out = (long) N * (N - 1) * (N - 2); } else { if (N % 3 == 0) out = (long) (N - 1) * (N - 2) * (N - 3); else out = (long) N * (N - 1) * (N - 3); } System.out.println(out); } } ","date":"2023-03-23","objectID":"/algo-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/:3:0","tags":["贪心","算法"],"title":"算法 ALGO 2 最大最小公倍数","uri":"/algo-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"试题 算法训练 K好数 ","date":"2023-03-23","objectID":"/algo-3-k%E5%A5%BD%E6%95%B0/:0:0","tags":["DP","算法"],"title":"算法 ALGO 3 K好数","uri":"/algo-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"题目 问题描述 如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。 输入格式 输入包含两个正整数，K和L。 输出格式 输出一个整数，表示答案对1000000007取模后的值。 样例输入 4 2 样例输出 7 数据规模与约定 对于30%的数据，KL \u003c= 106； 对于50%的数据，K \u003c= 16， L \u003c= 10； 对于100%的数据，1 \u003c= K,L \u003c= 100。 ","date":"2023-03-23","objectID":"/algo-3-k%E5%A5%BD%E6%95%B0/:1:0","tags":["DP","算法"],"title":"算法 ALGO 3 K好数","uri":"/algo-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"题解 该题可以使用动态规划。使用二维数组dp[L][K]保存计算过程，其中dp[i][j]表示i位K进制数（从第0位开始计）以j开头符合K好数规则的数的个数。 状态转移方程为： $$ dp[i][j]=\\sum ^{k-1}_{k=0} dp[i-1][k]-dp[i-1][j-1]-dp[i-1][j+1] $$ 由样例可知对四进制数01、02、03不看作K好数，即有效的数不能以0开头，所以需要对dp[i][0]做特殊处理。 ","date":"2023-03-23","objectID":"/algo-3-k%E5%A5%BD%E6%95%B0/:2:0","tags":["DP","算法"],"title":"算法 ALGO 3 K好数","uri":"/algo-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine()); int K = Integer.parseInt(stringTokenizer.nextToken()); int L = Integer.parseInt(stringTokenizer.nextToken()); int[][] dp = new int[L][K]; for (int i = 0; i \u003c K; i++) { dp[0][i] = 1; } for (int i = 1; i \u003c L; i++) { for (int j = 0; j \u003c K; j++) { for (int k = 0; k \u003c K; k++) { if (Math.abs(j - k) != 1) dp[i][j] = (dp[i][j] + dp[i - 1][k]) % 1000000007; } } } int out = 0; for (int i = 1; i \u003c K; i++) { out = (out + dp[L - 1][i]) % 1000000007; } System.out.println(out); } } ","date":"2023-03-23","objectID":"/algo-3-k%E5%A5%BD%E6%95%B0/:3:0","tags":["DP","算法"],"title":"算法 ALGO 3 K好数","uri":"/algo-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"注意 注意循环的起始条件，dp[i][0]不能因为数0ABCDEF……无效就简单赋值为0，因为dp[i+1][2]包含dp[i][0]，此时这个i+1位数是有效的。正确的做法是在计算结果时从dp[L-1][1]开始。 ","date":"2023-03-23","objectID":"/algo-3-k%E5%A5%BD%E6%95%B0/:4:0","tags":["DP","算法"],"title":"算法 ALGO 3 K好数","uri":"/algo-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"试题 算法训练 完全背包问题 ","date":"2023-03-21","objectID":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","tags":["DP","算法"],"title":"算法 ALGO 857 完全背包问题","uri":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"题目 问题描述 有一個背包，容量為M。有N種物品，每種物品有其體積Wi與價值Vi。將這些物品的一部分放入背包，每種物品可以放任意多個，要求總體積不超過容量，且總價值最大。 输入格式 第一行為N, M。 之後N行，每行為Wi, Vi。 输出格式 一個數，為最大價值。 样例输入 3 20 15 16 6 6 7 5 样例输出 18 数据规模和约定 N, M\u003c=1000。 ","date":"2023-03-21","objectID":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:1:0","tags":["DP","算法"],"title":"算法 ALGO 857 完全背包问题","uri":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"题解 可以与01背包问题比较，区别在于01背包每件物品只能放一次，完全背包每件物品可以放多次。 解题思路：通过动态规划，求解局部最优的同时记录，在增加一个物品后更新最优解。 设第i个物品体积为w[i]，价值为v[i]， f[i][j]表示选择前i个物品，背包剩余体积为j时的最优方案，即所选物品的最大权重和。 解法一： 状态转移方程 $$ f[i][j]=max(f[i-1][j-v[i]]+w[i],f[i-1][j]) $$ for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { f[i][j] = f[i - 1][j]; if (v[i] \u003e j) { // 防止数组越界 continue; } for (int k = 0; k * v[i] \u003c= j; k++) { f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); } } } 解法二： 状态转移方程 $$ f[i][j]=max(f[i-1][j-v[i]]+w[i],f[i-1][j]) $$ for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { if (j - w[i] \u003c 0) //剩余容量为j条件下无法再加第i个了 continue; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - w[i]] + v[i]); } } 解法三： 状态转移方程 $$ f[i][j]=max(f[i-1][j-v[i]]+w[i],f[i-1][j]) $$ for(int i = 1 ; i \u003c= n ; i++){ for(int v = w[i]; v \u003c= V ; v++){ // 正向枚举v dp[v] = max(dp[v],dp[v-w[i]] + c[i]); } } 写成一维形式之后和01背包完全相同，唯一的区别在于这里v的枚举顺序是正向枚举，而01背包的一维形式中v必须是逆向枚举。 ","date":"2023-03-21","objectID":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:2:0","tags":["DP","算法"],"title":"算法 ALGO 857 完全背包问题","uri":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer=new StringTokenizer(bufferedReader.readLine()); int N= Integer.parseInt(stringTokenizer.nextToken()); int M= Integer.parseInt(stringTokenizer.nextToken()); int[][] dp=new int[N+1][M+1]; int[] w=new int[N+1]; int[] v=new int[N+1]; for (int i = 1; i \u003c N+1; i++) { stringTokenizer=new StringTokenizer(bufferedReader.readLine()); w[i]= Integer.parseInt(stringTokenizer.nextToken()); v[i]= Integer.parseInt(stringTokenizer.nextToken()); } for (int i = 1; i \u003c N+1; i++) { for (int j = 0; j \u003c M+1; j++) { if (j-w[i]\u003c0) //剩余容量为j条件下无法再加第i个了 continue; dp[i][j]=Math.max(dp[i-1][j],dp[i][j-w[i]]+v[i]); //比较不放(dp[i-1][j])和放(dp[i][j-w[i]]+v[i])哪一个更优 } } System.out.print(dp[N][M]); } } ","date":"2023-03-21","objectID":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:0","tags":["DP","算法"],"title":"算法 ALGO 857 完全背包问题","uri":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"注意 三种解法依次优化。 if (v[i] \u003e j) 可以优化到 for (int j = 1; j \u003c= m; j ++ ) 中，优化后为： for (int j = v[i]; j \u003c= m; j ++ ) { } w[] 和 v[]可以优化掉。代码中的v和w数组使用仅限于i状态下，因此，可以定义两个变量，v和w，在for (int i = 1; i \u003c= n; i ++ )中输入即可，优化后： for (int i = 1; i \u003c= n; i++) { int v, w; Scanner scanner = new Scanner(System.in); v = scanner.nextInt(); w = scanner.nextInt(); scanner.nextLine(); } 参考资料 第二讲 完全背包问题 ","date":"2023-03-21","objectID":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:4:0","tags":["DP","算法"],"title":"算法 ALGO 857 完全背包问题","uri":"/algo-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"试题 算法训练 B君的希望 ","date":"2023-03-16","objectID":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:0:0","tags":["最长上升子序列","算法"],"title":"算法 ALGO 839 B君的希望","uri":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"题目 问题描述 你有个同学叫B君，他早听闻祖国河山秀丽，列了一张所有可能爬的山的高度表，因“人往高处走”的说法，所以他希望要爬的山按照表上的顺序，并且爬的每一座山都要比前一座高，爬的山数最多，请贵系的你帮他解决这个问题。(cin,cout很坑) 输入格式 输入第一行为num(1~1000)和maxHeight(1~8848)，代表山的个数和最大高度 输入第二行有num个整数，代表表上每座山的高度height(1~maxHeight) 输出格式 输出只有一个数，为符合要求的最大爬山数 样例输入 10 10 8 6 8 5 9 5 2 7 3 6 3 4 样例输出 3 样例输入 10 20 8 19 9 10 3 3 15 3 10 6 样例输出 4 数据规模和约定 num(1~1000)，maxHeight(1~8848)，height(1~maxHeight)，都是正整数 ","date":"2023-03-16","objectID":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:1:0","tags":["最长上升子序列","算法"],"title":"算法 ALGO 839 B君的希望","uri":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"题解 观察代码注释。 思路是记录局部最佳方案的值，再比较是否能在已有的方案上进一步增长递增序列长度。 ","date":"2023-03-16","objectID":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:2:0","tags":["最长上升子序列","算法"],"title":"算法 ALGO 839 B君的希望","uri":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer=new StringTokenizer(bufferedReader.readLine()); int num= Integer.parseInt(stringTokenizer.nextToken()); //只需要num，不需要保留maxHeight stringTokenizer=new StringTokenizer(bufferedReader.readLine()); int[] mounts=new int[num]; int[] re=new int[num]; //re[i]记录mounts[0]~mounts[i]的最长递增序列长度 for (int i = 0; i \u003c num; i++) mounts[i] = Integer.parseInt(stringTokenizer.nextToken()); re[0]=1; //可以爬mount[0]本身 int out=1; //目前全局最优为1 for (int i = 1; i \u003c num; i++) { int max=0; //最坏方案为0，同时也是目前的局部最优 for (int j = 0; j \u003c i; j++) { if(mounts[j]\u003cmounts[i]){ //意味着到mounts[j]的方案还可能被优化，即加上mounts[i] max=Math.max(max,re[j]); //判断是否更新目前的最优方案 } } re[i]=max+1; //re[i]包括mounts[i]本身，必然+1 out=Math.max(out,re[i]); //在计算过程中保留全局最优 } System.out.print(out); } } ","date":"2023-03-16","objectID":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:3:0","tags":["最长上升子序列","算法"],"title":"算法 ALGO 839 B君的希望","uri":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"注意 可以在计算过程中保留全局最优。 ","date":"2023-03-16","objectID":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:4:0","tags":["最长上升子序列","算法"],"title":"算法 ALGO 839 B君的希望","uri":"/algo-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"试题 算法训练 筛法 ","date":"2023-03-11","objectID":"/algo-964-%E7%AD%9B%E6%B3%95/:0:0","tags":["筛法","算法"],"title":"算法 ALGO 964 筛法","uri":"/algo-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"题目 问题描述 炫炫学了筛法之后，很想用筛法求欧拉函数。他决定求1到N的所有数的欧拉函数值。 输入格式 输入的第一行包含1个整数n,。 输出格式 输出若干行，每行包含一个整数，第i行表示i的欧拉函数值 样例输入 2 样例输出 1 1 数据规模和约定 n\u003c=500000 ","date":"2023-03-11","objectID":"/algo-964-%E7%AD%9B%E6%B3%95/:1:0","tags":["筛法","算法"],"title":"算法 ALGO 964 筛法","uri":"/algo-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"题解 该题考查素数筛。素数筛有埃氏筛（the Sieve of Eratosthenes，埃拉托色尼筛）和欧拉筛（the Sieve of Euler，也叫线性筛）。可以通过筛出1~N的所有素数来求解欧拉函数。 求欧拉函数数值有公式： $$ \\phi(n)=\\prod^r_{i=1}(\\frac{p_i-1}{p_i}) $$ 其中任何一个大于1的自然数n,如果n不为质数，那么n可以唯一分解成有限个质数的乘积 $$ n=p_1^{k_1}p_2^{k_2}\\dots p_r^{k_r} $$ 根据线性筛同时求解欧拉函数值，可以根据三条性质来求解 $$ 设p为素数，有如下关系：\\ \\phi(p)=p-1\\ p与i互素 \\ \\phi(p \\cdot i)=\\phi(p)\\cdot \\phi(i)\\ p为i的质因数 \\ \\phi(p \\cdot i)=p \\cdot \\phi(i) $$ ","date":"2023-03-11","objectID":"/algo-964-%E7%AD%9B%E6%B3%95/:2:0","tags":["筛法","算法"],"title":"算法 ALGO 964 筛法","uri":"/algo-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static int[] eulerSet; //eulerSet[i]对应i的欧拉函数值 public static boolean[] isComposite; //如果i为合数，isComposite[i]为true public static int[] primeSet; //存储算出的素数 public static int cnt = 0; //算出的素数个数 public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(bufferedReader.readLine()); eulerSet = new int[n + 1]; primeSet = new int[n]; isComposite = new boolean[n + 1]; getPrime(n); for (int i = 1; i \u003c n + 1; i++) { System.out.println(eulerSet[i]); } } public static void getPrime(int n) { //欧拉筛（线性筛）判断是否为素数，同时记录欧拉函数值 eulerSet[1] = 1; for (int i = 2; i \u003c= n; i++) { if (!isComposite[i]) { //若i为质数 primeSet[cnt] = i; //将质数i记录 cnt++; eulerSet[i] = i - 1; //欧拉函数为i-1 } for (int j = 0; primeSet[j] * i \u003c= n; j++) { isComposite[primeSet[j] * i] = true; if (i % primeSet[j] == 0) { //primeSet[j]为i的最小质因数，同时也为primeSet[j]*i的最小质因数 eulerSet[primeSet[j] * i] = eulerSet[i] * primeSet[j]; break; //算完最小的质因数，后面再算会产生重复 } eulerSet[primeSet[j] * i] = eulerSet[i] * (primeSet[j] - 1); //primeSet[j]不为i的最小质因数，primeSet[j]与i互素 } } } } ","date":"2023-03-11","objectID":"/algo-964-%E7%AD%9B%E6%B3%95/:3:0","tags":["筛法","算法"],"title":"算法 ALGO 964 筛法","uri":"/algo-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"注意 考虑到时间复杂度，需要使用欧拉筛。 我一开始的思路是先求解1~n的所有素数，再对每一个数做质因数分解，根据公式求每一个数的欧拉函数值，然而超时。故转为在筛选素数的同时计算每一个数的欧拉函数值。 ","date":"2023-03-11","objectID":"/algo-964-%E7%AD%9B%E6%B3%95/:4:0","tags":["筛法","算法"],"title":"算法 ALGO 964 筛法","uri":"/algo-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"试题 算法训练 过河马 ","date":"2023-03-09","objectID":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:0:0","tags":["DP","递推","算法"],"title":"算法 ALGO 981 过河马","uri":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"题目 问题描述 在那个过河卒逃过了马的控制以超级超级多的走法走到了终点之后，这匹马表示它不开心了…… 于是，终于有一天，它也过河了！ 由于过河马积累了许多的怨念，所以这次它过了河之后，再也没有什么东西可以限制它，它可以自由自在的在棋盘上驰骋。一开始，它是在一个n行m列棋盘的左下角（1,1）的位置，它想要走到终点右上角（n，m）的位置。而众所周知，马是要走日子格的。可是这匹马在积累了这么多怨念之后，它再也不想走回头路——也就是说，它只会朝向上的方向跳，不会朝向下的方向跳。 那么，这匹马它也想知道，它想从起点跳到终点，一共有多少种走法呢？ 输入格式 第一行两个数n，m，表示一个n行m列的棋盘，马最初是在左下角（1,1）的位置，终点在右上角（n，m）的位置。 输出格式 输出有一行，一个数表示走法数。由于答案可能很大，所以输出答案除以1000000007所得的余数即可。 样例输入 4 4 样例输出 2 数据规模和约定 n\u003c=100,m\u003c=100 ","date":"2023-03-09","objectID":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:1:0","tags":["DP","递推","算法"],"title":"算法 ALGO 981 过河马","uri":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"题解 由于题目规定马只能朝上跳，所以不会存在循环的情况，且棋盘第1行易知不可到达。可用动态规划，即棋盘的某一位置(i,j)只能由其下面的四个位置到达。通过二维数组来记录每个位置的走法数，设[i][j]的值为走法数，有如下递推关系： $$ [i][j]=[i-1][j-2]+[i-1][j+2]+[i-2][j-1]+[i-2][j+1] $$ 只要在程序中判断来源的四个位置是否合法即可。 ","date":"2023-03-09","objectID":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:2:0","tags":["DP","递推","算法"],"title":"算法 ALGO 981 过河马","uri":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer = null; int n, m; try { stringTokenizer = new StringTokenizer(bufferedReader.readLine()); } catch (IOException e) { throw new RuntimeException(e); } n = Integer.parseInt(stringTokenizer.nextToken()); m = Integer.parseInt(stringTokenizer.nextToken()); long[][] dp = new long[n][m]; dp[0][0] = 1; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c m; j++) { if (i - 1 \u003e -1 \u0026\u0026 j - 2 \u003e -1) //i-1\u003cn\u0026\u0026i-1\u003e-1\u0026\u0026j-2\u003e-1\u0026\u0026j-2\u003cm dp[i][j] = (dp[i][j] + dp[i - 1][j - 2]) % 1000000007; if (i - 1 \u003e -1 \u0026\u0026 j + 2 \u003e -1 \u0026\u0026 j + 2 \u003c m) //i-1\u003cn\u0026\u0026i-1\u003e-1\u0026\u0026j+2\u003e-1\u0026\u0026j+2\u003cm dp[i][j] = (dp[i][j] + dp[i - 1][j + 2]) % 1000000007; if (i - 2 \u003e -1 \u0026\u0026 j - 1 \u003e -1) //i-2\u003cn\u0026\u0026i-2\u003e-1\u0026\u0026j-1\u003e-1\u0026\u0026j-1\u003cm dp[i][j] = (dp[i][j] + dp[i - 2][j - 1]) % 1000000007; if (i - 2 \u003e -1 \u0026\u0026 j + 1 \u003c m) //i-2\u003cn\u0026\u0026i-2\u003e-1\u0026\u0026j+1\u003e-1\u0026\u0026j+1\u003cm dp[i][j] = (dp[i][j] + dp[i - 2][j + 1]) % 1000000007; } } System.out.println(dp[n - 1][m - 1] % 1000000007); } } ","date":"2023-03-09","objectID":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:3:0","tags":["DP","递推","算法"],"title":"算法 ALGO 981 过河马","uri":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"注意 由于n\u003c=100,m\u003c=100，输入较大时结果用int类型会溢出，建议使用long类型，且在运算过程中取余。 ","date":"2023-03-09","objectID":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:4:0","tags":["DP","递推","算法"],"title":"算法 ALGO 981 过河马","uri":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"拓展 同样是马走日，如果没有限定只能朝上跳，那么无法计算出所有走法了。 算法-ALGO-1001-跳马 ","date":"2023-03-09","objectID":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:5:0","tags":["DP","递推","算法"],"title":"算法 ALGO 981 过河马","uri":"/algo-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"试题 算法训练 数的潜能 ","date":"2023-03-09","objectID":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:0:0","tags":["算法"],"title":"算法 ALGO 999 数的潜能","uri":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"题目 问题描述 将一个数N分为多个正整数之和，即N=a1+a2+a3+…+ak，定义M=a1a2a3*…*ak为N的潜能。 给定N，求它的潜能M。 由于M可能过大，只需求M对5218取模的余数。 输入格式 输入共一行，为一个正整数N。 输出格式 输出共一行，为N的潜能M对5218取模的余数。 样例输入 10 样例输出 36 数据规模和约定 1\u003c=N\u003c10^18 ","date":"2023-03-09","objectID":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:1:0","tags":["算法"],"title":"算法 ALGO 999 数的潜能","uri":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"题解 该题为找规律题。 先尝试从比较小的数开始分解，得到其最大的分解方法： N 最大的分解方法 1 就是1本身 2 就是2本身 3 就是3本身 4 就是4本身，或者是2+2 5 2+3 6 3+3 7 4+3=2+2+3 8 2+3+3 9 3+3+3 10 2+2+3+3 11 2+3+3+3 12 3+3+3+3 13 2+2+3+3+3 14 2+3+3+3+3 可以发现除去1以后，分解具有如下规律： 尽量3进行分解 如果3分解有余，则用剩余部分用2分解 同时发现若分解成9+9的形式可以减少计算，计算时间更长，但实现更简单，原理同快速幂算法。 可以使用快速幂算法进行幂运算，此处不赘述。 ","date":"2023-03-09","objectID":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:2:0","tags":["算法"],"title":"算法 ALGO 999 数的潜能","uri":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); long N; try { N = Long.parseLong(bufferedReader.readLine()); } catch (IOException e) { throw new RuntimeException(e); } if (N \u003c 4) { System.out.println(N); return; } int rest = (int) (N % 3); int result = 0; if (rest == 0) { N /= 3; result = qpow(3, N, 5218); } else if (rest == 1) { N = (N - 4) / 3; result = (qpow(3, N, 5218) * 4) % 5218; } else { N = (N - 2) / 3; result = (qpow(3, N, 5218) * 2) % 5218; } System.out.println(result); } public static int qpow(long b, long e, int mod) { \\\\快速幂 int result = 1; while (e != 0) { if ((e \u0026 1) == 1) result = (int) ((result * (b % mod)) % mod); b = (b * b) % mod; e \u003e\u003e= 1; } return result; } } ","date":"2023-03-09","objectID":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:3:0","tags":["算法"],"title":"算法 ALGO 999 数的潜能","uri":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"注意 对1~3需要进行特判。 由于输入的数可能比较大，所以应该使用long关键字。 分解后进行累乘时，由于指数可能比较大，推荐使用快速幂，或将数分解为9+9的形式，结果相同。 快速幂函数中推荐每一步都取余，防止数溢出。 ","date":"2023-03-09","objectID":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:4:0","tags":["算法"],"title":"算法 ALGO 999 数的潜能","uri":"/algo-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"试题 算法训练 跳马 ","date":"2023-03-08","objectID":"/algo-1001-%E8%B7%B3%E9%A9%AC/:0:0","tags":["状态搜索","算法"],"title":"算法 ALGO 1001 跳马","uri":"/algo-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"题目 问题描述 一个8×8的棋盘上有一个马初始位置为(a,b)，他想跳到(c,d)，问是否可以？如果可以，最少要跳几步？ 输入格式 一行四个数字a,b,c,d。 输出格式 如果跳不到，输出-1；否则输出最少跳到的步数。 样例输入 1 1 2 3 样例输出 1 数据规模和约定 0\u003ca,b,c,d≤8且都是整数。 ","date":"2023-03-08","objectID":"/algo-1001-%E8%B7%B3%E9%A9%AC/:1:0","tags":["状态搜索","算法"],"title":"算法 ALGO 1001 跳马","uri":"/algo-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"题解 使用DFS搜索，退出条件为： 搜索步数大于目前的最小步数 调到目标位置，记录步数 遍历所有结果，每一个可到达位置都走过了（最坏，即不可到达） 可以将一些变量保存为静态变量，而不是在递归函数中声明，也不是通过形参传入，目的是减少内存消耗，同时使方法间可以共享信息。 ","date":"2023-03-08","objectID":"/algo-1001-%E8%B7%B3%E9%A9%AC/:2:0","tags":["状态搜索","算法"],"title":"算法 ALGO 1001 跳马","uri":"/algo-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static int result = -1; public static int x0, y0, x1, y1; public static int[][] array = new int[9][9]; public static int[][] horse = {% raw %} {{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1}}; {% endraw %} public static void main(String[] args) { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); try { StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine()); x0 = Integer.parseInt(stringTokenizer.nextToken()); y0 = Integer.parseInt(stringTokenizer.nextToken()); x1 = Integer.parseInt(stringTokenizer.nextToken()); y1 = Integer.parseInt(stringTokenizer.nextToken()); } catch (IOException e) { throw new RuntimeException(e); } array[x0][y0] = 1; dfs(x0, y0, 0); System.out.println(result); } public static void dfs(int x, int y, int step) { if (result != -1) if (step \u003e= result) return; if (x == x1 \u0026\u0026 y == y1) { result = step; return; } int xTemp, yTemp; for (int i = 0; i \u003c 8; i++) { xTemp = x + horse[i][0]; yTemp = y + horse[i][1]; if (xTemp \u003e 0 \u0026\u0026 xTemp \u003c= 8 \u0026\u0026 yTemp \u003e 0 \u0026\u0026 yTemp \u003c= 8) { if (array[xTemp][yTemp] == 0) { array[xTemp][yTemp] = 1; dfs(xTemp, yTemp, step + 1); array[xTemp][yTemp] = 0; } else return; } } } } ","date":"2023-03-08","objectID":"/algo-1001-%E8%B7%B3%E9%A9%AC/:3:0","tags":["状态搜索","算法"],"title":"算法 ALGO 1001 跳马","uri":"/algo-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"注意 需要一个二维数组保存DFS中走过的位置，在递归后恢复为走过的状态。其中起始位置一定是走过的。 一定要剪枝，否则无论输入为何，计算过程中都会将所有可能路径完整计算一遍，肯定超时。 注意该题的棋盘是有范围的，一开始想通过不定方程组来求解，理论上不存在不能到达的位置。但由于该题棋盘有限，该方法不建议使用。 ","date":"2023-03-08","objectID":"/algo-1001-%E8%B7%B3%E9%A9%AC/:4:0","tags":["状态搜索","算法"],"title":"算法 ALGO 1001 跳马","uri":"/algo-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"拓展 算法-ALGO-981-过河马 ","date":"2023-03-08","objectID":"/algo-1001-%E8%B7%B3%E9%A9%AC/:5:0","tags":["状态搜索","算法"],"title":"算法 ALGO 1001 跳马","uri":"/algo-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"试题 算法训练 拿金币 ","date":"2023-03-02","objectID":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:0:0","tags":["DP","算法"],"title":"算法 ALGO 1006 拿金币","uri":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"},{"categories":["算法"],"content":"题目 问题描述 有一个N x N的方格,每一个格子都有一些金币,只要站在格子里就能拿到里面的金币。你站在最左上角的格子里,每次可以从一个格子走到它右边或下边的格子里。请问如何走才能拿到最多的金币。 输入格式 ​ 第一行输入一个正整数n。 ​ 以下n行描述该方格。金币数保证是不超过1000的正整数。 输出格式 最多能拿金币数量。 样例输入 3 1 3 3 2 2 2 3 1 2 样例输出 11 数据规模和约定 ​ n\u003c=1000 ","date":"2023-03-02","objectID":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:1:0","tags":["DP","算法"],"title":"算法 ALGO 1006 拿金币","uri":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"},{"categories":["算法"],"content":"题解 可以判断此题属于动态规划题。用一个二维数组存储输入，并加以处理即可。由于只能向左或向右，通过计算得到一个新的二维数组，其中a[i][j]表示在此位置的最优路径的各节点权重之和。**可以通过按行从左往右依次遍历原数组，比较每一个元素的左元素和上元素，取二者权重较大的和该元素生成新元素的值。**即 array[i][j] += Math.max(array[i][j - 1], array[i - 1][j]) 最终右下角元素的值就是答案。 ","date":"2023-03-02","objectID":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:2:0","tags":["DP","算法"],"title":"算法 ALGO 1006 拿金币","uri":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); int n=Integer.parseInt(bufferedReader.readLine()); int[][] array=new int[n+1][n+1]; for (int i = 1; i \u003c n+1; i++) { String s =bufferedReader.readLine(); StringTokenizer stringTokenizer = new StringTokenizer(s); for (int j = 1; j \u003c n + 1; j++){ array[i][j]=Integer.parseInt(stringTokenizer.nextToken()); } } for (int i = 1; i \u003c n+1; i++) { for (int j = 1; j \u003c n + 1; j++) { array[i][j] += Math.max(array[i][j - 1], array[i - 1][j]); } } System.out.println(array[n][n]); } } ","date":"2023-03-02","objectID":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:3:0","tags":["DP","算法"],"title":"算法 ALGO 1006 拿金币","uri":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"},{"categories":["算法"],"content":"注意 小技巧：使用BufferedReader类。一开始我使用Scanner类输入数据，提交显示内存超限。通过查询，发现BufferedReader类在内存使用方面消耗更少，于是用BufferedReader类代替了Scanner类。 Scanner类和BufferedReader类不能混用，猜测是由于缓冲区的原因。一旦使用Scanner类读取输入（我这里是使用Scanner类读取了n的值，BufferedReader类尝试读取其它数据），则BufferedReader类只能读取到新输入的字符串（即无法读取其它数据），导致结果报错。 ","date":"2023-03-02","objectID":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:4:0","tags":["DP","算法"],"title":"算法 ALGO 1006 拿金币","uri":"/algo-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"}]