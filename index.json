[{"categories":["算法"],"content":"零钱兑换II ","date":"2024-03-25","objectID":"/%E5%8A%9B%E6%89%A3-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii/:0:0","tags":["数组","动态规划"],"title":"力扣 518 零钱兑换II","uri":"/%E5%8A%9B%E6%89%A3-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii/"},{"categories":["算法"],"content":"题目 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 示例 1： 输入：amount = 5, coins = [1, 2, 5] 输出：4 解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 示例 2： 输入：amount = 3, coins = [2] 输出：0 解释：只用面额 2 的硬币不能凑成总金额 3 。 示例 3： 输入：amount = 10, coins = [10] 输出：1 提示： 1 \u003c= coins.length \u003c= 300 1 \u003c= coins[i] \u003c= 5000 coins 中的所有值 互不相同 0 \u003c= amount \u003c= 5000 ","date":"2024-03-25","objectID":"/%E5%8A%9B%E6%89%A3-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii/:1:0","tags":["数组","动态规划"],"title":"力扣 518 零钱兑换II","uri":"/%E5%8A%9B%E6%89%A3-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii/"},{"categories":["算法"],"content":"题解 思考一：为什么这种循环顺序不会造成重复排列。如果是以下循环顺序，会怎么样。 for k, _ in enumerate(amounts): for i in coins: 思考二：如果要求凑出金额的最少硬币个数，该如何修改代码。322. 零钱兑换 ","date":"2024-03-25","objectID":"/%E5%8A%9B%E6%89%A3-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii/:2:0","tags":["数组","动态规划"],"title":"力扣 518 零钱兑换II","uri":"/%E5%8A%9B%E6%89%A3-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii/"},{"categories":["算法"],"content":"代码 class Solution: def change(self, amount: int, coins: List[int]) -\u003e int: coins = set(i for i in coins if i \u003c= amount) amounts = [0 for _ in range(amount + 1)] amounts[0] = 1 for i in coins: for k, _ in enumerate(amounts): if k - i \u003e= 0 and amounts[k - i] != 0: amounts[k] += amounts[k - i] return amounts[amount] 思考二 class Solution: def coinChange(self, coins: List[int], amount: int) -\u003e int: if amount == 0: return 0 coins = [i for i in coins if i \u003c= amount] amounts = [-1 for _ in range(amount + 1)] for i in coins: amounts[i] = 1 for k, v in enumerate(amounts): if v == 1: continue for i in coins: if k - i \u003e 0 and amounts[k - i] != -1: if amounts[k] != -1: amounts[k] = min(amounts[k], amounts[k - i] + 1) else: amounts[k] = amounts[k - i] + 1 return amounts[amount] ","date":"2024-03-25","objectID":"/%E5%8A%9B%E6%89%A3-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii/:3:0","tags":["数组","动态规划"],"title":"力扣 518 零钱兑换II","uri":"/%E5%8A%9B%E6%89%A3-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii/"},{"categories":["算法"],"content":"好子数组的最大分数 ","date":"2024-03-19","objectID":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/:0:0","tags":["栈","数组","双指针","二分查找","单调栈"],"title":"力扣 1793 好子数组的最大分数","uri":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"},{"categories":["算法"],"content":"题目 给你一个整数数组 nums **（下标从 0 开始）**和一个整数 k 。 一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i \u003c= k \u003c= j 。 请你返回 好 子数组的最大可能 分数 。 示例 1： 输入：nums = [1,4,3,7,4,5], k = 3 输出：15 解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。 示例 2： 输入：nums = [5,5,4,5,4,1,1,1], k = 0 输出：20 解释：最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。 提示： 1 \u003c= nums.length \u003c= 105 1 \u003c= nums[i] \u003c= 2 * 104 0 \u003c= k \u003c nums.length ","date":"2024-03-19","objectID":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/:1:0","tags":["栈","数组","双指针","二分查找","单调栈"],"title":"力扣 1793 好子数组的最大分数","uri":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"},{"categories":["算法"],"content":"题解 ","date":"2024-03-19","objectID":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/:2:0","tags":["栈","数组","双指针","二分查找","单调栈"],"title":"力扣 1793 好子数组的最大分数","uri":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"},{"categories":["算法"],"content":"方法一：双指针 由于好子数组必须要包含 $\\textit{nums}[k]$，那么我们可以使用两个指针 $\\textit{left}$ 和 $\\textit{right}$ 表示选择的子数组为 $(\\textit{left}, \\textit{right})$ （左开右开），且 $\\textit{left}$ 和 $\\textit{right}$ 的初始值为 $k-1$ 和 $k+1$。 随后我们可以枚举子数组分数定义中 $\\min { \\cdots }$ 部分的值。它的最大值为 $\\textit{nums}[k]$，最小值为数组 $\\textit{nums}$ 中的最小值。随后我们从大到小进行枚举，当枚举到 $i$ 时，我们可以不断向左移动 $\\textit{left}$，或者向右移动 $\\textit{right}$，直到： 指针超出数组的边界，或者 指针指向的元素小于 $i$，分数定义中的 $\\min{ \\cdots }$ 的值发生了变化。 当移动完成后，$(\\textit{left}, \\textit{right})$ 就是最小值大于等于 $i$ 的一个子数组，它的分数至少为： $$ (\\textit{right} - \\textit{left} - 1) \\times i $$ 当 $i$ 恰好是 $(\\textit{left}, \\textit{right})$ 的最小值时，上式就是它对应的分数。当 $i$ 继续减少但指针没有移动时，上式计算出的分数会比正确的分数要低，但一定不会更高。因此，只要我们在枚举的过程中维护上式的最大值，就可以得到正确的答案。 当两个指针都超出数组的边界时，就可以结束枚举并返回答案。 ","date":"2024-03-19","objectID":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/:2:1","tags":["栈","数组","双指针","二分查找","单调栈"],"title":"力扣 1793 好子数组的最大分数","uri":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"},{"categories":["算法"],"content":"方法二：优化的双指针 我们可以对方法一中的代码进行优化。 方法一效率较低的原因是在 $i$ 比 $(\\textit{left}, \\textit{right})$ 中的最小值更小，但指针没有移动时，计算出的分数是没有意义的。指针没有移动的原因是 $\\textit{nums}[\\textit{left}]$ 和 $\\textit{nums}[\\textit{right}]$ 都小于 $i$，因此我们应当直接把 $i$ 减少至二者的较大值，而不是每次减少 $1$，这样就可以保证每一次循环中都至少会移动一次指针，就可以将 $C$ 从时间复杂度 $O(n+C)$ 中移除。 细节 在减少 $i$ 时，需要注意指针已经超出数组边界的情况。 ","date":"2024-03-19","objectID":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/:2:2","tags":["栈","数组","双指针","二分查找","单调栈"],"title":"力扣 1793 好子数组的最大分数","uri":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"},{"categories":["算法"],"content":"代码 方法一：双指针 class Solution: def maximumScore(self, nums: List[int], k: int) -\u003e int: n = len(nums) left, right = k - 1, k + 1 ans = 0 for i in range(nums[k], 0, -1): while left \u003e= 0 and nums[left] \u003e= i: left -= 1 while right \u003c n and nums[right] \u003e= i: right += 1 ans = max(ans, (right - left - 1) * i) return ans 方法二：优化的双指针 class Solution: def maximumScore(self, nums: List[int], k: int) -\u003e int: n = len(nums) left, right, i = k - 1, k + 1, nums[k] ans = 0 while True: while left \u003e= 0 and nums[left] \u003e= i: left -= 1 while right \u003c n and nums[right] \u003e= i: right += 1 ans = max(ans, (right - left - 1) * i) i = max((-1 if left == -1 else nums[left]), (-1 if right == n else nums[right])) if i == -1: break return ans ","date":"2024-03-19","objectID":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/:3:0","tags":["栈","数组","双指针","二分查找","单调栈"],"title":"力扣 1793 好子数组的最大分数","uri":"/%E5%8A%9B%E6%89%A3-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"},{"categories":["算法"],"content":"找出数组的第K大和 ","date":"2024-03-09","objectID":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/:0:0","tags":["数组","排序","堆（优先队列）"],"title":"力扣 2386 找出数组的第K大和","uri":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/"},{"categories":["算法"],"content":"题目 给你一个整数数组 nums 和一个 正 整数 k 。你可以选择数组的任一 子序列 并且对其全部元素求和。 数组的 第 k 大和 定义为：可以获得的第 k 个 最大 子序列和（子序列和允许出现重复） 返回数组的 第 k 大和 。 子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。 **注意：**空子序列的和视作 0 。 示例 1： 输入：nums = [2,4,-2], k = 5 输出：2 解释：所有可能获得的子序列和列出如下，按递减顺序排列： - 6、4、4、2、2、0、0、-2 数组的第 5 大和是 2 。 示例 2： 输入：nums = [1,-2,3,4,-10,12], k = 16 输出：10 解释：数组的第 16 大和是 10 。 提示： n == nums.length 1 \u003c= n \u003c= 105 -109 \u003c= nums[i] \u003c= 109 1 \u003c= k \u003c= min(2000, 2n) ","date":"2024-03-09","objectID":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/:1:0","tags":["数组","排序","堆（优先队列）"],"title":"力扣 2386 找出数组的第K大和","uri":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/"},{"categories":["算法"],"content":"题解 ","date":"2024-03-09","objectID":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/:2:0","tags":["数组","排序","堆（优先队列）"],"title":"力扣 2386 找出数组的第K大和","uri":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/"},{"categories":["算法"],"content":"方法一：优先队列 首先，考虑该问题的简化版：给定 $n$ 个非递减的非负数序列 $a_0, a_1, \\cdots, a_{n-1}$ ，找出第 k$$ 个最小的子序列和。 当 $k = 1$ 时，空序列即为答案。 当$k \\gt 1$，令 $(t, i)$ 表示以 $a_i$ 为最后一个元素且和为 ttt 的子序列，则问题转化为求解第 $k$ 个最小的 $(t, i)$。我们使用一个小根堆来保存 $(t, i)$，初始时堆中只有一个元素 $(a_0, 0)$。为了能按从小到大的顺序依次获得子序列，当我们从小根堆取出堆顶元素 $(t, i)$ 时，我们需要进行以下操作： 将 $a_{i + 1}$ 拼接到子序列 $(t, i)$ 后，得到新的子序列 $(t + a_{i + 1}, i + 1)$，并将它加入堆中。 将子序列 $(t, i)$ 中的 $a_i$ 替换成 $a_{i+1}$，得到新的子序列 $(t + a_{i + 1} - a_i, i + 1)$，并将它加入堆中。 那么第 $k - 1$ 次取出的堆顶元素对应第 $k$ 个最小的子序列。 这种做法可以保证： 不重复地取出所有的非空子序列 依次取出的非空子序列和是非递减的。 根据以上讨论，我们可以求解出非递减的非负数序列的第 $k$ 个最小的子序列和，而原问题给出的条件中，允许序列中有负数。记原序列的非负数和与负数和分别为 $\\textit{total}$ 与 $\\textit{total}_\\textit{neg}$，我们先将原序列中的负数替换成它的绝对值，然后从小到大进行排序，最后求解第 $k$ 个最小的子序列和 $t_k$ 。 $t_k$ 对应一个子序列 $s_k$，我们将 $t_k$ 加上 $\\textit{total}\\textit{neg}$，那么 $t_k + \\textit{total}\\textit{neg}$ 也对应原序列的一个子序列 $s_k’$，该子序列 $s_k’$ 的正数元素与 $s_k$ 相同，负数部分由绝对值不存在于 $s_k$ 的负数元素组成。因为 $t_k + \\textit{total}\\textit{neg}$ 是非递减的，所以 $s_k’$ 是原序列的第 $k$ 个最小的子序列，$t_k + \\textit{total}\\textit{neg}$ 是原序列的第 $k$ 个最小的子序列和。 同时，如果第 $k$ 个最小的子序列和为 $t_k + \\textit{total}\\textit{neg}$ ，并且所有序列元素和为 $\\textit{total} + \\textit{total}\\textit{neg}$，那么 $\\textit{total} + \\textit{total}\\textit{neg} - (t_k + \\textit{total}\\textit{neg}) = \\textit{total} - t_k$ 即为第 kkk 个最大的子序列和。 $\\textit{total} - t_k$ 对应没有出现在第 $k$ 个最小的子序列中的元素和，也对应一个子序列，因为 $t_k$ 是非递减的，所以 $\\textit{total} - t_k$ 是非递增的，因此 $\\textit{total} - t_k$ 即为第 $k$ 个最大的子序列和。 ","date":"2024-03-09","objectID":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/:2:1","tags":["数组","排序","堆（优先队列）"],"title":"力扣 2386 找出数组的第K大和","uri":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/"},{"categories":["算法"],"content":"方法二：二分 对于问题：给定 $n$ 个非递减的非负数序列 $a_0, a_1, \\cdots, a_{n-1}$，找出第 $k$ 个最小的子序列和。除了使用堆，我们还可以使用二分算法来解决。记 $\\textit{total}_2$ 为非负数序列的和，令 $\\textit{left} = 0, \\textit{right} = \\textit{total}_2$，那么在区间 $[\\textit{left}, \\textit{right}]$ 进行二分搜索。 令当前搜索的值为 $\\textit{mid} = \\lfloor \\frac{(\\textit{left} + \\textit{right})}{2} \\rfloor$，令 $\\textit{cnt}$ 为和小于等于 $\\textit{mid}$ 的非空子序列的个数，求解 $\\textit{cnt}$ 可以使用深度优先搜索，假设当前搜索到第 $i$ 个元素，前面已选中的元素和为 $t$： 如果 $\\textit{cnt} \\ge k - 1$ 或 $t + a_i \\gt \\textit{mid}$，那么说明后续的搜索不必要，直接返回。 否则， $t + a_i$ 即对应以 $a_i$ 为最后一个元素的子序列和，将 $\\textit{cnt}$ 加一，然后同时对 $(i + 1, t + a_i)$ 和 $(i + 1, t)$ 进行搜索。 最后，如果 $\\textit{cnt} \\ge k - 1$，令 $\\textit{right} = \\textit{mid} - 1$，否则令 $\\textit{left} = \\textit{mid} + 1$。当 $\\textit{left} \\gt \\textit{right}$ 时，$\\textit{left}$ 即为第 $k$ 个最小的子序列和。后续问题的求解同方法一。 ","date":"2024-03-09","objectID":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/:2:2","tags":["数组","排序","堆（优先队列）"],"title":"力扣 2386 找出数组的第K大和","uri":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/"},{"categories":["算法"],"content":"代码 方法一：优先队列 class Solution: def kSum(self, nums: List[int], k: int) -\u003e int: n = len(nums) total = 0 for i in range(n): if nums[i] \u003e= 0: total += nums[i] else: nums[i] = -nums[i] nums.sort() ret = 0 pq = [(nums[0], 0)] for j in range(2, k + 1): t, i = heappop(pq) ret = t if i == n - 1: continue heappush(pq, (t + nums[i + 1], i + 1)) heappush(pq, (t - nums[i] + nums[i + 1], i + 1)) return total - ret 方法二：二分 class Solution: def kSum(self, nums: List[int], k: int) -\u003e int: n = len(nums) total, total2 = 0, 0 for i in range(n): if nums[i] \u003e= 0: total += nums[i] else: nums[i] = -nums[i] total2 += nums[i] nums.sort() cnt = 0 def dfs(i: int, t: int, limit: int) -\u003e int: nonlocal cnt if i == n or cnt \u003e= k - 1 or t + nums[i] \u003e limit: return cnt += 1 dfs(i + 1, t + nums[i], limit) dfs(i + 1, t, limit) left, right = 0, total2 while left \u003c= right: mid = (left + right) // 2 cnt = 0 dfs(0, 0, mid) if cnt \u003e= k - 1: right = mid - 1 else: left = mid + 1 return total - left ","date":"2024-03-09","objectID":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/:3:0","tags":["数组","排序","堆（优先队列）"],"title":"力扣 2386 找出数组的第K大和","uri":"/%E5%8A%9B%E6%89%A3-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%92%8C/"},{"categories":["算法"],"content":"检查数组是否存在有效划分 ","date":"2024-03-01","objectID":"/%E5%8A%9B%E6%89%A3-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86/:0:0","tags":["数组","动态规划"],"title":"力扣 2369 检查数组是否存在有效划分","uri":"/%E5%8A%9B%E6%89%A3-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86/"},{"categories":["算法"],"content":"题目 给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。 如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分： 子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。 子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。 子数组 恰 由 3 个连续递增元素组成，并且相邻元素之间的差值为 1 。例如，子数组 [3,4,5] ，但是子数组 [1,3,5] 不符合要求。 如果数组 至少 存在一种有效划分，返回 true ，否则，返回 false 。 示例 1： 输入：nums = [4,4,4,5,6] 输出：true 解释：数组可以划分成子数组 [4,4] 和 [4,5,6] 。 这是一种有效划分，所以返回 true 。 示例 2： 输入：nums = [1,1,1,2] 输出：false 解释：该数组不存在有效划分。 提示： 2 \u003c= nums.length \u003c= 105 1 \u003c= nums[i] \u003c= 106 ","date":"2024-03-01","objectID":"/%E5%8A%9B%E6%89%A3-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86/:1:0","tags":["数组","动态规划"],"title":"力扣 2369 检查数组是否存在有效划分","uri":"/%E5%8A%9B%E6%89%A3-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86/"},{"categories":["算法"],"content":"题解 设数组 $\\textit{nums}$ 的长度为 $n$，它至少存在一个有效划分的充要条件为： 前 $(n-2)$ 个元素组成的数组至少存在一个有效划分，且后两个元素相等。或 前 $(n-3)$ 个元素组成的数组至少存在一个有效划分，且 后三个元素相等。或 后三个元素连续递增，且差值为 $1$。 这样的判断可以用动态规划来解决，用一个长度为 $(n+1)$ 的数组来记录 $\\textit{nums}$ 是否存在有效划分，$\\textit{dp}[i]$ 表示前 iii 个元素组成的数组是否至少存在一个有效划分。边界情况 dp[0]dp[0]dp[0] 恒为 $\\texttt{true}$，而 $dp[n]$ 即为结果。 同时，定义两个辅助函数，$\\textit{validTwo}(\\textit{num}_1, \\textit{nums}_2)$ 用来判断长度为 $2$ 的子数组是否满足题目的条件 $1$。$\\textit{validThree}(\\textit{num}_1, \\textit{nums}_2, \\textit{nums}_3)$ 用来判断长度为 333 的子数组是否满足题目的条件 $2$ 或 $3$。 这样，动态规划的公式即为 $$ \\begin{aligned} \\textit{dp}[i] = \u0026 (\\textit{dp}[i - 2]\\wedge\\textit{validTwo}(\\textit{nums}[i - 2], \\textit{nums}[i - 1])) \\vee\\\u0026(\\textit{dp}[i - 3]\\wedge\\textit{validThree}(\\textit{nums}[i - 3], \\textit{nums}[i - 2], \\textit{nums}[i - 1])) \\end{aligned} $$ 。推导的时候需要注意下标是否越界。 ","date":"2024-03-01","objectID":"/%E5%8A%9B%E6%89%A3-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86/:2:0","tags":["数组","动态规划"],"title":"力扣 2369 检查数组是否存在有效划分","uri":"/%E5%8A%9B%E6%89%A3-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86/"},{"categories":["算法"],"content":"代码 class Solution: def validPartition(self, nums: List[int]) -\u003e bool: n = len(nums) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): if i \u003e= 2: dp[i] = dp[i - 2] and self.validTwo(nums[i - 2], nums[i - 1]) if i \u003e= 3: dp[i] = dp[i] or (dp[i - 3] and self.validThree(nums[i - 3], nums[i - 2], nums[i - 1])) return dp[-1] def validTwo(self, num1: int, num2: int) -\u003e bool: return num1 == num2 def validThree(self, num1: int, num2: int, num3: int) -\u003e bool: return (num1 == num2 == num3) or (num1 + 2 == num2 + 1 == num3) ","date":"2024-03-01","objectID":"/%E5%8A%9B%E6%89%A3-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86/:3:0","tags":["数组","动态规划"],"title":"力扣 2369 检查数组是否存在有效划分","uri":"/%E5%8A%9B%E6%89%A3-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86/"},{"categories":["算法"],"content":"统计可能的树根数目 ","date":"2024-02-29","objectID":"/%E5%8A%9B%E6%89%A3-2581-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE/:0:0","tags":["树","深度优先搜索","哈希表","动态规划"],"title":"力扣 2581 统计可能的树根数目","uri":"/%E5%8A%9B%E6%89%A3-2581-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE/"},{"categories":["算法"],"content":"题目 Alice 有一棵 n 个节点的树，节点编号为 0 到 n - 1 。树用一个长度为 n - 1 的二维整数数组 edges 表示，其中 edges[i] = [ai, bi] ，表示树中节点 ai 和 bi 之间有一条边。 Alice 想要 Bob 找到这棵树的根。她允许 Bob 对这棵树进行若干次 猜测 。每一次猜测，Bob 做如下事情： 选择两个 不相等 的整数 u 和 v ，且树中必须存在边 [u, v] 。 Bob 猜测树中 u 是 v 的 父节点 。 Bob 的猜测用二维整数数组 guesses 表示，其中 guesses[j] = [uj, vj] 表示 Bob 猜 uj 是 vj 的父节点。 Alice 非常懒，她不想逐个回答 Bob 的猜测，只告诉 Bob 这些猜测里面 至少 有 k 个猜测的结果为 true 。 给你二维整数数组 edges ，Bob 的所有猜测和整数 k ，请你返回可能成为树根的 节点数目 。如果没有这样的树，则返回 0。 示例 1： 输入：edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3 输出：3 解释： 根为节点 0 ，正确的猜测为 [1,3], [0,1], [2,4] 根为节点 1 ，正确的猜测为 [1,3], [1,0], [2,4] 根为节点 2 ，正确的猜测为 [1,3], [1,0], [2,4] 根为节点 3 ，正确的猜测为 [1,0], [2,4] 根为节点 4 ，正确的猜测为 [1,3], [1,0] 节点 0 ，1 或 2 为根时，可以得到 3 个正确的猜测。 示例 2： 输入：edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1 输出：5 解释： 根为节点 0 ，正确的猜测为 [3,4] 根为节点 1 ，正确的猜测为 [1,0], [3,4] 根为节点 2 ，正确的猜测为 [1,0], [2,1], [3,4] 根为节点 3 ，正确的猜测为 [1,0], [2,1], [3,2], [3,4] 根为节点 4 ，正确的猜测为 [1,0], [2,1], [3,2] 任何节点为根，都至少有 1 个正确的猜测。 提示： edges.length == n - 1 2 \u003c= n \u003c= 105 1 \u003c= guesses.length \u003c= 105 0 \u003c= ai, bi, uj, vj \u003c= n - 1 ai != bi uj != vj edges 表示一棵有效的树。 guesses[j] 是树中的一条边。 guesses 是唯一的。 0 \u003c= k \u003c= guesses.length ","date":"2024-02-29","objectID":"/%E5%8A%9B%E6%89%A3-2581-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE/:1:0","tags":["树","深度优先搜索","哈希表","动态规划"],"title":"力扣 2581 统计可能的树根数目","uri":"/%E5%8A%9B%E6%89%A3-2581-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE/"},{"categories":["算法"],"content":"题解 首先计算固定树根时猜对的次数，假设以 $0$ 号节点为树根，从它开始执行深度优先搜索，使用哈希表统计所有树边 $(x, y)$ 在 $\\textit{guesses}$ 中出现的个数，其中 $x$ 是 $y$ 的父节点。 然后考虑树根从 $0$ 移动到 $0$ 的子节点后，所有 $\\textit{guesses}$ 的状态变化。如下图所示，树根从 $x$ 变成 $y$ 之后，只有 $(x, y)$ 和 $(y, x)$ 这两个猜测的正确性发生变化。 因此基于已经计算出以 $x$ 为树根时猜对的次数，很容易就可以计算出以 $y$ 为树根时猜对的次数： 如果 $(x, y)$ 存在 $\\textit{guesses}$，猜对次数减一； 如果 $(y, x)$ 存在于 $\\textit{guesses}$，猜对次数加一。 最终答案就是所有猜对次数大于等于 $k$ 的节点个数。 需要注意的是，某些语言可能需要手写树边 $(x, y)$ 的哈希函数，由于树上节点编号不超过 $10^5$ ，而且 $2^{20} \u003e 10^5$ ，因此我们可以用 $x \\times 2^{20} + y$ 作为哈希函数。 ","date":"2024-02-29","objectID":"/%E5%8A%9B%E6%89%A3-2581-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE/:2:0","tags":["树","深度优先搜索","哈希表","动态规划"],"title":"力扣 2581 统计可能的树根数目","uri":"/%E5%8A%9B%E6%89%A3-2581-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE/"},{"categories":["算法"],"content":"代码 class Solution: def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -\u003e int: n = len(edges) + 1 g = [[] for _ in range(n)] st = set() def h(x, y): return x \u003c\u003c 20 | y for x, y in edges: g[x].append(y) g[y].append(x) for u, v in guesses: st.add(h(u, v)) res, cnt = 0, 0 def dfs(x, fat): nonlocal cnt for y in g[x]: if y == fat: continue cnt += h(x, y) in st dfs(y, x) dfs(0, -1) def redfs(x, fat, cnt): nonlocal res if cnt \u003e= k: res += 1 for y in g[x]: if y == fat: continue redfs(y, x, cnt - (h(x, y) in st) + (h(y, x) in st)) redfs(0, -1, cnt) return res ","date":"2024-02-29","objectID":"/%E5%8A%9B%E6%89%A3-2581-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE/:3:0","tags":["树","深度优先搜索","哈希表","动态规划"],"title":"力扣 2581 统计可能的树根数目","uri":"/%E5%8A%9B%E6%89%A3-2581-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE/"},{"categories":["算法"],"content":"使二叉树所有路径值相等的最小代价 ","date":"2024-02-28","objectID":"/%E5%8A%9B%E6%89%A3-2673-%E4%BD%BF%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/:0:0","tags":["贪心","树","数组","动态规划","二叉树"],"title":"力扣 2673 使二叉树所有路径值相等的最小代价","uri":"/%E5%8A%9B%E6%89%A3-2673-%E4%BD%BF%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/"},{"categories":["算法"],"content":"题目 给你一个整数 n 表示一棵 满二叉树 里面节点的数目，节点编号从 1 到 n 。根节点编号为 1 ，树中每个非叶子节点 i 都有两个孩子，分别是左孩子 2 * i 和右孩子 2 * i + 1 。 树中每个节点都有一个值，用下标从 0 开始、长度为 n 的整数数组 cost 表示，其中 cost[i] 是第 i + 1 个节点的值。每次操作，你可以将树中 任意 节点的值 增加 1 。你可以执行操作 任意 次。 你的目标是让根到每一个 叶子结点 的路径值相等。请你返回 最少 需要执行增加操作多少次。 注意： 满二叉树 指的是一棵树，它满足树中除了叶子节点外每个节点都恰好有 2 个子节点，且所有叶子节点距离根节点距离相同。 路径值 指的是路径上所有节点的值之和。 示例 1： 输入：n = 7, cost = [1,5,2,2,3,3,1] 输出：6 解释：我们执行以下的增加操作： - 将节点 4 的值增加一次。 - 将节点 3 的值增加三次。 - 将节点 7 的值增加两次。 从根到叶子的每一条路径值都为 9 。 总共增加次数为 1 + 3 + 2 = 6 。 这是最小的答案。 示例 2： 输入：n = 3, cost = [5,3,3] 输出：0 解释：两条路径已经有相等的路径值，所以不需要执行任何增加操作。 提示： 3 \u003c= n \u003c= 105 n + 1 是 2 的幂 cost.length == n 1 \u003c= cost[i] \u003c= 104 ","date":"2024-02-28","objectID":"/%E5%8A%9B%E6%89%A3-2673-%E4%BD%BF%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/:1:0","tags":["贪心","树","数组","动态规划","二叉树"],"title":"力扣 2673 使二叉树所有路径值相等的最小代价","uri":"/%E5%8A%9B%E6%89%A3-2673-%E4%BD%BF%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/"},{"categories":["算法"],"content":"题解 我们首先考虑所有的叶结点。 对于任一叶结点，它的值为 $x$，它的兄弟节点的值为 $y$。可以发现，对于树上的其余节点，它们要么同时是这两个叶节点的祖先，要么同时不是这两个叶节点的祖先。对这些节点进行一次操作，要么同时增加了根到这两个叶节点的路径值 $1$，要么没有任何效果。因此，要想使得根到这两个叶节点的路径值相等，我们只能增加 $x$ 和 $y$ 本身。 由于我们希望操作次数最少，那么应该进行 $|x - y|$ 次操作，将较小的值增加至与较大的值相等。 待考虑完所有叶节点之后，互为兄弟节点的叶节点的值两两相等（并且根到它们的路径值显然也相等）。如果我们还需要操作某个叶节点，那么为了使得路径值相等，它的兄弟节点同样也需要操作。此时就需要两次操作，但不如直接操作它们的双亲节点，可以省去一次操作。 因此，所有的叶节点都无需进行操作。我们就可以将它们全部移除。为了使得路径值保持不变，我们可以将叶节点的值增加至它们的双亲节点。这样一来，所有的双亲节点都变成了新的叶节点，我们重复进行上述操作即可。当只剩一个节点（根节点）时，就可以得到最终的答案。 细节 由于本题中的树是以数组形式给定的，因此只需要对数组进行一次逆序遍历，就等价于对整个树进行了一次从叶节点开始的，自底向上的遍历。 ","date":"2024-02-28","objectID":"/%E5%8A%9B%E6%89%A3-2673-%E4%BD%BF%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/:2:0","tags":["贪心","树","数组","动态规划","二叉树"],"title":"力扣 2673 使二叉树所有路径值相等的最小代价","uri":"/%E5%8A%9B%E6%89%A3-2673-%E4%BD%BF%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/"},{"categories":["算法"],"content":"代码 class Solution: def minIncrements(self, n: int, cost: List[int]) -\u003e int: ans = 0 for i in range(n - 2, 0, -2): ans += abs(cost[i] - cost[i + 1]) # 叶节点 i 和 i+1 的双亲节点下标为 i/2（整数除法） cost[i // 2] += max(cost[i], cost[i + 1]) return ans ","date":"2024-02-28","objectID":"/%E5%8A%9B%E6%89%A3-2673-%E4%BD%BF%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/:3:0","tags":["贪心","树","数组","动态规划","二叉树"],"title":"力扣 2673 使二叉树所有路径值相等的最小代价","uri":"/%E5%8A%9B%E6%89%A3-2673-%E4%BD%BF%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/"},{"categories":["算法"],"content":"统计树中的合法路径数目 ","date":"2024-02-27","objectID":"/%E5%8A%9B%E6%89%A3-2867-%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE/:0:0","tags":["树","深度优先搜索","数学","动态规划","数论"],"title":"力扣 2867 统计树中的合法路径数目","uri":"/%E5%8A%9B%E6%89%A3-2867-%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE/"},{"categories":["算法"],"content":"题目 给你一棵 n 个节点的无向树，节点编号为 1 到 n 。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示节点 ui 和 vi 在树中有一条边。 请你返回树中的 合法路径数目 。 如果在节点 a 到节点 b 之间 恰好有一个 节点的编号是质数，那么我们称路径 (a, b) 是 合法的 。 注意： 路径 (a, b) 指的是一条从节点 a 开始到节点 b 结束的一个节点序列，序列中的节点 互不相同 ，且相邻节点之间在树上有一条边。 路径 (a, b) 和路径 (b, a) 视为 同一条 路径，且只计入答案 一次 。 示例 1： 输入：n = 5, edges = [[1,2],[1,3],[2,4],[2,5]] 输出：4 解释：恰好有一个质数编号的节点路径有： - (1, 2) 因为路径 1 到 2 只包含一个质数 2 。 - (1, 3) 因为路径 1 到 3 只包含一个质数 3 。 - (1, 4) 因为路径 1 到 4 只包含一个质数 2 。 - (2, 4) 因为路径 2 到 4 只包含一个质数 2 。 只有 4 条合法路径。 示例 2： 输入：n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]] 输出：6 解释：恰好有一个质数编号的节点路径有： - (1, 2) 因为路径 1 到 2 只包含一个质数 2 。 - (1, 3) 因为路径 1 到 3 只包含一个质数 3 。 - (1, 4) 因为路径 1 到 4 只包含一个质数 2 。 - (1, 6) 因为路径 1 到 6 只包含一个质数 3 。 - (2, 4) 因为路径 2 到 4 只包含一个质数 2 。 - (3, 6) 因为路径 3 到 6 只包含一个质数 3 。 只有 6 条合法路径。 提示： 1 \u003c= n \u003c= 105 edges.length == n - 1 edges[i].length == 2 1 \u003c= ui, vi \u003c= n 输入保证 edges 形成一棵合法的树。 ","date":"2024-02-27","objectID":"/%E5%8A%9B%E6%89%A3-2867-%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE/:1:0","tags":["树","深度优先搜索","数学","动态规划","数论"],"title":"力扣 2867 统计树中的合法路径数目","uri":"/%E5%8A%9B%E6%89%A3-2867-%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE/"},{"categories":["算法"],"content":"题解 根据题意，我们需要知道一个数是不是质数，可以采用「埃氏筛」来找出范围内所有的质数。关于质数筛选，可以参考题解204. 计数质数。 然后我们分别以质数节点为根，用「深度优先搜索」的方式，递归搜索所有的非质数的子树，并求出所有子树的大小，搜索过程中只搜索非质数节点。任何两个来自不同子树的节点，其路径都通过质数根节点，路径上恰好只有根节点一个质数节点，根据题意路径是合法的。我们只需要把所子树大小，两两相乘并求和，就可以得到包含根节点的所有合法路径。 遍历所有质数节点，并且重复上述过程，便可以得到所有合法路径的数目，返回为最终结果。 ","date":"2024-02-27","objectID":"/%E5%8A%9B%E6%89%A3-2867-%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE/:2:0","tags":["树","深度优先搜索","数学","动态规划","数论"],"title":"力扣 2867 统计树中的合法路径数目","uri":"/%E5%8A%9B%E6%89%A3-2867-%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE/"},{"categories":["算法"],"content":"代码 # 埃氏筛 N = 10001 is_prime = [True] * N is_prime[1] = False for i in range(2, N): if is_prime[i]: for j in range(i * i, N, i): is_prime[j] = False class Solution: def countPaths(self, n: int, edges: List[List[int]]) -\u003e int: G = [[] for _ in range(n + 1)] for i, j in edges: G[i].append(j) G[j].append(i) def dfs(i, pre): seen.append(i) for j in G[i]: if j != pre and not is_prime[j]: dfs(j, i) res = 0 count = [0] * (n + 1) for i in range(1, n + 1): if not is_prime[i]: continue cur = 0 for j in G[i]: if is_prime[j]: continue if count[j] == 0: seen = [] dfs(j, 0) for k in seen: count[k] = len(seen) res += count[j] * cur cur += count[j] res += cur return res ","date":"2024-02-27","objectID":"/%E5%8A%9B%E6%89%A3-2867-%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE/:3:0","tags":["树","深度优先搜索","数学","动态规划","数论"],"title":"力扣 2867 统计树中的合法路径数目","uri":"/%E5%8A%9B%E6%89%A3-2867-%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%95%B0%E7%9B%AE/"},{"categories":["算法"],"content":"根据前序和后序遍历构造二叉树 ","date":"2024-02-22","objectID":"/%E5%8A%9B%E6%89%A3-889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["树","数组","哈希表","分治","二叉树"],"title":"力扣 889 根据前序和后序遍历构造二叉树","uri":"/%E5%8A%9B%E6%89%A3-889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["算法"],"content":"题目 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。 如果存在多个答案，您可以返回其中 任何 一个。 示例 1： 输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1] 输出：[1,2,3,4,5,6,7] 示例 2: 输入: preorder = [1], postorder = [1] 输出: [1] 提示： 1 \u003c= preorder.length \u003c= 30 1 \u003c= preorder[i] \u003c= preorder.length preorder 中所有值都 不同 postorder.length == preorder.length 1 \u003c= postorder[i] \u003c= postorder.length postorder 中所有值都 不同 保证 preorder 和 postorder 是同一棵二叉树的前序遍历和后序遍历 ","date":"2024-02-22","objectID":"/%E5%8A%9B%E6%89%A3-889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:1:0","tags":["树","数组","哈希表","分治","二叉树"],"title":"力扣 889 根据前序和后序遍历构造二叉树","uri":"/%E5%8A%9B%E6%89%A3-889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["算法"],"content":"题解 方法一：递归 前序遍历为： （根结点）（前序遍历左分支）（前序遍历右分支） 而后序遍历为： （后序遍历左分支）（后序遍历右分支）（根结点） 例如，如果最终的二叉树可以被序列化的表述为 $[1, 2, 3, 4, 5, 6, 7]$，那么其前序遍历为 $[1] + [2, 4, 5] + [3, 6, 7]$，而后序遍历为 $[4, 5, 2] + [6, 7, 3] + [1]$。 如果我们知道左分支有多少个结点，我们就可以对这些数组进行分组，并用递归生成树的每个分支。 我们令左分支有 $L$ 个节点。我们知道左分支的头节点为 $pre[1]$，但它也出现在左分支的后序表示的最后。所以 $pre[1] = post[L-1]$（因为结点的值具有唯一性），因此 $L = post.indexOf(pre[1]) + 1$。 现在在我们的递归步骤中，左分支由 $pre[1 : L+1]$ 和 $post[0:L]$ 重新分支，而右分支将由 $pre[L+1 : N]$ 和 $post[L : N-1]$ 重新分支。 方法二：递归（优化） 令 $n$ 为二叉树的节点数目，那么根据前序遍历与后序遍历的定义，$\\textit{preorder}[0]$ 与 $\\textit{postorder}[n - 1]$ 都对应二叉树的根节点。获取根节点后，我们需要划分根节点的左子树与右子树，考虑两种情况： 原二叉树的根节点的左子树不为空，那么 $\\textit{preorder}[1]$ 对应左子树的根节点； 原二叉树的根节点的左子树为空，那么 $\\textit{preorder}[1]$ 对应右子树的根节点。 对于以上两种情况，我们无法区分 $\\textit{preorder}[1]$ 到底是哪种情况。但是对于第二种情况，将原二叉树的右子树移到左子树后得到的二叉树的前序遍历数组与后序遍历数组与原二叉树相同，所以我们只需要考虑第一种情况。因为二叉树的值互不相同，我们可以在 $\\textit{postorder}$ 中找到 $\\textit{postorder}[k] = \\textit{preorder}[1]$，那么左子树的节点数目为 $k + 1$。基于此，我们可以对 $\\textit{preorder}$ 和 $\\textit{postorder}$ 进行分治处理，即将 $\\textit{preorder}$ 划分为根节点、左子树节点和右子树节点三个部分，$\\textit{postorder}$ 也划分为左子树节点、右子树节点和根节点三个部分。那么问题划分为： 根据左子树节点的前序遍历与后序遍历数组构造二叉树； 根据右子树节点的前序遍历与后序遍历数组构造二叉树。 同时当节点数目为 $1$ 时，对应构造的二叉树只有一个节点。我们可以递归地对问题进行求解，就可得到构造的二叉树。 ","date":"2024-02-22","objectID":"/%E5%8A%9B%E6%89%A3-889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:2:0","tags":["树","数组","哈希表","分治","二叉树"],"title":"力扣 889 根据前序和后序遍历构造二叉树","uri":"/%E5%8A%9B%E6%89%A3-889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["算法"],"content":"代码 方法一：递归 class Solution(object): def constructFromPrePost(self, pre, post): if not pre: return None root = TreeNode(pre[0]) if len(pre) == 1: return root L = post.index(pre[1]) + 1 root.left = self.constructFromPrePost(pre[1:L+1], post[:L]) root.right = self.constructFromPrePost(pre[L+1:], post[L:-1]) return root 方法二：递归（优化） class Solution: def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -\u003e Optional[TreeNode]: postMap = {x: i for i, x in enumerate(postorder)} def dfs(preLeft, preRight, postLeft, postRight): if preLeft \u003e preRight: return None leftCount = 0 if preLeft \u003c preRight: leftCount = postMap[preorder[preLeft + 1]] - postLeft + 1 return TreeNode(preorder[preLeft], dfs(preLeft + 1, preLeft + leftCount, postLeft, postLeft + leftCount - 1), dfs(preLeft + leftCount + 1, preRight, postLeft + leftCount, postRight - 1)) return dfs(0, len(preorder) - 1, 0, len(postorder) - 1) ","date":"2024-02-22","objectID":"/%E5%8A%9B%E6%89%A3-889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/:3:0","tags":["树","数组","哈希表","分治","二叉树"],"title":"力扣 889 根据前序和后序遍历构造二叉树","uri":"/%E5%8A%9B%E6%89%A3-889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["算法"],"content":"跳跃游戏 VI ","date":"2024-02-05","objectID":"/%E5%8A%9B%E6%89%A3-1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi/:0:0","tags":["队列","数组","动态规划","单调队列","堆（优先队列）"],"title":"力扣 1696 跳跃游戏 VI","uri":"/%E5%8A%9B%E6%89%A3-1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi/"},{"categories":["算法"],"content":"题目 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。 一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。 你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。 请你返回你能得到的 最大得分 。 示例 1： 输入：nums = [1,-1,-2,4,-7,3], k = 2 输出：7 解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。 示例 2： 输入：nums = [10,-5,-2,4,0,3], k = 3 输出：17 解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。 示例 3： 输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2 输出：0 提示： 1 \u003c= nums.length, k \u003c= 105 -104 \u003c= nums[i] \u003c= 104 ","date":"2024-02-05","objectID":"/%E5%8A%9B%E6%89%A3-1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi/:1:0","tags":["队列","数组","动态规划","单调队列","堆（优先队列）"],"title":"力扣 1696 跳跃游戏 VI","uri":"/%E5%8A%9B%E6%89%A3-1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi/"},{"categories":["算法"],"content":"题解 每一个位置的最大值取决于前面 $k$ 步的最大得分，再加上当前位置的得分，由此我们想到可以使用动态规划来解决这个问题。 用 $\\textit{dp}[i]$ 来表示到达位置 $i$ 的最大得分。初始状态 $\\textit{dp}[0] = \\textit{nums}[0]$，表示位置 $0$ 的得分是它本身的得分。状态转移方程是 $$ \\textit{dp}[i] = \\max{\\textit{dp}[j]} 其中 max⁡(0,i−k)≤j\u003ci\\max(0, i - k) \\leq j \u003c imax(0,i−k)≤j\u003ci。 $$ 其中前 $k$ 步的最大值，使用优先队列可以达到 $O(n\\times\\log{n})$ 的时间复杂度，使用双端队列可以达到 $O(n)$ 的时间复杂度。具体解释，可以参考下题解「239. 滑动窗口最大值」。 本题解采用双端队列来解决。 ","date":"2024-02-05","objectID":"/%E5%8A%9B%E6%89%A3-1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi/:2:0","tags":["队列","数组","动态规划","单调队列","堆（优先队列）"],"title":"力扣 1696 跳跃游戏 VI","uri":"/%E5%8A%9B%E6%89%A3-1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi/"},{"categories":["算法"],"content":"代码 class Solution: def maxResult(self, nums: List[int], k: int) -\u003e int: n = len(nums) dp = [0] * n dp[0] = nums[0] queue = deque([0]) for i in range(1, n): while queue and queue[0] \u003c i - k: queue.popleft() dp[i] = dp[queue[0]] + nums[i] while queue and dp[queue[-1]] \u003c= dp[i]: queue.pop() queue.append(i) return dp[n - 1] ","date":"2024-02-05","objectID":"/%E5%8A%9B%E6%89%A3-1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi/:3:0","tags":["队列","数组","动态规划","单调队列","堆（优先队列）"],"title":"力扣 1696 跳跃游戏 VI","uri":"/%E5%8A%9B%E6%89%A3-1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi/"},{"categories":["算法"],"content":"石子游戏 VII ","date":"2024-02-03","objectID":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/:0:0","tags":["数组","数学","动态规划","博弈"],"title":"力扣 1690 石子游戏 VII","uri":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/"},{"categories":["算法"],"content":"题目 石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，爱丽丝先开始 。 有 n 块石子排成一排。每个玩家的回合中，可以从行中 移除 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 和 相等的得分。当没有石头可移除时，得分较高者获胜。 鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 减小得分的差值 。爱丽丝的目标是最大限度地 扩大得分的差值 。 给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，如果爱丽丝和鲍勃都 发挥出最佳水平 ，请返回他们 得分的差值 。 示例 1： 输入：stones = [5,3,1,4,2] 输出：6 解释： - 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。 - 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。 - 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。 - 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。 - 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。 得分的差值 18 - 12 = 6 。 示例 2： 输入：stones = [7,90,5,1,100,10,10,2] 输出：122 提示： n == stones.length 2 \u003c= n \u003c= 1000 1 \u003c= stones[i] \u003c= 1000 ","date":"2024-02-03","objectID":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/:1:0","tags":["数组","数学","动态规划","博弈"],"title":"力扣 1690 石子游戏 VII","uri":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/"},{"categories":["算法"],"content":"题解 ","date":"2024-02-03","objectID":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/:2:0","tags":["数组","数学","动态规划","博弈"],"title":"力扣 1690 石子游戏 VII","uri":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/"},{"categories":["算法"],"content":"方法一：记忆化搜索 思路与算法 根据题意可知有 $n$ 块石子，游戏的每个回合中，选手可以从行中移除最左边的石头或最右边的石头，并获得与该行中剩余石头值之和相等的得分。由于先手的 $\\text{Bob}$ 一定会输，此时 $\\text{Bob}$ 与 $\\text{Alice}$ 得分的差值一定小于 $0$；$\\text{Alice}$ 一定会赢，此时 $\\text{Alice}$ 与 $\\text{Bob}$ 得分的差值一定大于 $0$，$\\text{Bob}$ 尽力减小得分的差值，$\\text{Alice}$ 的尽量扩大得分的差值，二者的博弈过程即等价于不管是 $\\text{Bob}$ 还是 $\\text{Alice}$ 都尽可能的扩大得分的差值。根据题意可以推出，假设当前石头序列固定，则不管是 $\\text{Alice}$ 先手还是 $\\text{Bob}$ 先手，二者之间得分的最大差值一定是确定的。 假设当前只剩下索引区间 $[i,j]$ 的石头待选择，此时对于该轮选手来说，它的最优解到底是该选最左侧的 $i$ 还是右侧的元素 $j$ 呢？假设当前只剩下 $[s_i,s_{i+1},s_{i+2},s_{i+3},\\cdots,s_j]$，且此时轮到 $\\text{Bob}$ 选择，$\\text{Bob}$ 有两种选择： 假设 $\\text{Bob}$ 首先拿走的是 $s_i$ ，则其得分为 $\\sum_{k=i+1}^{j}$，剩余的元素为 $[s_{i+1},s_{i+2},s_{i+3},\\cdots,s_j]$，由于 $\\text{Alice}$ 想努力的扩大得分差值，假设 $\\text{Alice}$ 在剩余石头序列 $[s_{i+1},s_{i+2},s_{i+3},\\cdots,s_j]$ 中游戏的得分与 $\\text{Bob}$ 得分最大差值为 $f(i+1,j)$，此时 $\\text{Bob}$ 与 $\\text{Alice}$ 的得分差值即为 $\\sum_{k=i+1}^{j} - f(i+1,j)$ 假设 $\\text{Bob}$ 首先拿走的是 $s_j$ ，则其得分为 $\\sum_{k=i}^{j-1}$，剩余的元素为 $[s_{i},s_{i+1},s_{i+2},\\cdots,s_{j-1}]$，由于 $\\text{Alice}$ 想努力的扩大得分差值，假设 $\\text{Alice}$ 在剩余石头序列 $[s_{i},s_{i+1},s_{i+2},\\cdots,s_{j-1}]$ 中游戏的得分与 $\\text{Bob}$ 得分最大差值为 $f(i,j-1)$，此时 $\\text{Bob}$ 与 $\\text{Alice}$ 的得分差值即为 $\\sum_{k=i}^{j-1} - f(i,j-1)$； 此时可以知道序列 $[s_i,s_{i+1},s_{i+2},s_{i+3},\\cdots,s_j]$ 中，$\\text{Bob}$ 与 $\\text{Alice}$ 得分差的最大值 为 $f(i,j) = \\max(\\sum_{k=i+1}^{j} - f(i+1,j), \\sum_{k=i}^{j-1} - f(i,j-1))$，综上可以得知最大得分差可以理解为此次操作之后，当前选手所收获的价值 - 剩余序列中对手与自己的得分差的最大值。 根据上述推论，我们可以采用自顶向下的记忆化搜索，如要求得区间 $[i,j]$ 得分的最大差值为 $f(i,j)$，此时根据上述的分析需要求出子区间 $[i,j-1]$ 与 $[i+1,j]$ 的最优值即可。由于每次移除石头的得分为区间的累加和，此时我们可以维护序列的前缀和，即可快速求出区间和。 ","date":"2024-02-03","objectID":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/:2:1","tags":["数组","数学","动态规划","博弈"],"title":"力扣 1690 石子游戏 VII","uri":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/"},{"categories":["算法"],"content":"方法二：动态规划 思路与算法 方法的一的策略还是可以采用自底向上的动态规划，我们可以首先求出区间 $[i,i]$ 的最大得分差值，然后不断向外扩展求出 $[i−1,i]$，$[i,i+1]$ 区间的最优解，一直扩展到区间 $[0,n−1]$，此时即可求出最优解返回即可。 ","date":"2024-02-03","objectID":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/:2:2","tags":["数组","数学","动态规划","博弈"],"title":"力扣 1690 石子游戏 VII","uri":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/"},{"categories":["算法"],"content":"代码 方法一：记忆化搜索 class Solution: def stoneGameVII(self, stones: List[int]) -\u003e int: pre = [0] for s in stones: pre.append(pre[-1] + s) @cache def dfs(i, j): if i \u003e j: return 0 return max(pre[j + 1] - pre[i + 1] - dfs(i + 1, j), pre[j] - pre[i] - dfs(i, j - 1)) res = dfs(0, len(stones) - 1) dfs.cache_clear() return res 方法二：动态规划 class Solution: def stoneGameVII(self, stones: List[int]) -\u003e int: pre = [0] for s in stones: pre.append(pre[-1] + s) @cache def dfs(i, j): if i \u003e j: return 0 return max(pre[j + 1] - pre[i + 1] - dfs(i + 1, j), pre[j] - pre[i] - dfs(i, j - 1)) res = dfs(0, len(stones) - 1) dfs.cache_clear() return res ","date":"2024-02-03","objectID":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/:3:0","tags":["数组","数学","动态规划","博弈"],"title":"力扣 1690 石子游戏 VII","uri":"/%E5%8A%9B%E6%89%A3-1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-vii/"},{"categories":["算法"],"content":"数字游戏 ","date":"2024-02-01","objectID":"/%E5%8A%9B%E6%89%A3-lcp-24-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/:0:0","tags":["数组","数学","堆（优先队列）"],"title":"力扣 LCP 24 数字游戏","uri":"/%E5%8A%9B%E6%89%A3-lcp-24-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"题目 小扣在秋日市集入口处发现了一个数字游戏。主办方共有 N 个计数器，计数器编号为 0 ~ N-1。每个计数器上分别显示了一个数字，小扣按计数器编号升序将所显示的数字记于数组 nums。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。 主办方请小扣回答出一个长度为 N 的数组，第 i 个元素(0 \u003c= i \u003c N)表示将 0~i 号计数器 初始 所示数字操作成满足所有条件 nums[a]+1 == nums[a+1],(0 \u003c= a \u003c i) 的最小操作数。回答正确方可进入秋日市集。 由于答案可能很大，请将每个最小操作数对 1,000,000,007 取余。 示例 1： 输入：nums = [3,4,5,1,6,7] 输出：[0,0,0,5,6,7] 解释： i = 0，[3] 无需操作 i = 1，[3,4] 无需操作； i = 2，[3,4,5] 无需操作； i = 3，将 [3,4,5,1] 操作成 [3,4,5,6], 最少 5 次操作； i = 4，将 [3,4,5,1,6] 操作成 [3,4,5,6,7], 最少 6 次操作； i = 5，将 [3,4,5,1,6,7] 操作成 [3,4,5,6,7,8]，最少 7 次操作； 返回 [0,0,0,5,6,7]。 示例 2： 输入：nums = [1,2,3,4,5] 输出：[0,0,0,0,0] 解释：对于任意计数器编号 i 都无需操作。 示例 3： 输入：nums = [1,1,1,2,3,4] 输出：[0,1,2,3,3,3] 解释： i = 0，无需操作； i = 1，将 [1,1] 操作成 [1,2] 或 [0,1] 最少 1 次操作； i = 2，将 [1,1,1] 操作成 [1,2,3] 或 [0,1,2]，最少 2 次操作； i = 3，将 [1,1,1,2] 操作成 [1,2,3,4] 或 [0,1,2,3]，最少 3 次操作； i = 4，将 [1,1,1,2,3] 操作成 [-1,0,1,2,3]，最少 3 次操作； i = 5，将 [1,1,1,2,3,4] 操作成 [-1,0,1,2,3,4]，最少 3 次操作； 返回 [0,1,2,3,3,3]。 提示： 1 \u003c= nums.length \u003c= 10^5 1 \u003c= nums[i] \u003c= 10^3 ","date":"2024-02-01","objectID":"/%E5%8A%9B%E6%89%A3-lcp-24-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/:1:0","tags":["数组","数学","堆（优先队列）"],"title":"力扣 LCP 24 数字游戏","uri":"/%E5%8A%9B%E6%89%A3-lcp-24-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"题解 **将 $[0, i]$ 范围内的计数器初始所示数字操作成满足所有条件 $\\textit{nums}[j] + 1 = \\textit{nums}[j + 1], j \\in [0, i)$，等价于，将 $\\textit{nums}[j] - j, j \\in [0, i)$ 操作成相同的数字。**因此，先对数组 $\\textit{nums}$ 作预处理，即令 $\\textit{nums}[i] = \\textit{nums}[i] - i$。 将区间 $[0, i]$ 范围内的数字操作成相同的数字的最小操作数，等于将区间 $[0,i]$ 范围内的数字操作成它们的中位数所需要的操作数。证明过程可以参考462. 最小操作次数使数组元素相等 II。 我们分别使用两个优先队列 $\\textit{lower}$ 和 $\\textit{upper}$ 来保存 $[0,i]$ 内的数字，同时使用 $\\textit{lowerSum}$ 和 $\\textit{upperSum}$ 分别保存两个优先队列的元素和，这两个优先队列中的元素满足以下两个条件： 优先队列 $\\textit{lower}$ 保存的任一元素都小于等于优先队列 $\\textit{upper}$ 保存的任一元素； 优先队列 $\\textit{lower}$ 的元素数目 $n_\\textit{lower}$ 与优先队列 $\\textit{upper}$ 的元素数目 $n_\\textit{upper}$ 满足 $n_\\textit{upper} \\le n_\\textit{lower} \\le n_\\textit{upper} + 1$ 遍历数组 $\\textit{nums}$，假设当前遍历到元素 $\\textit{nums}[i]$，考虑如何将元素 $\\textit{nums}[i]$ 加入优先队列，同时不违反以上条件。首先如果 $\\textit{lower}$ 为空或 $\\textit{nums}[i]$ 小于 $\\textit{lower}$ 的最大元素，那么我们将 $\\textit{nums}[i]$ 加入 $\\textit{lower}$，更新 $\\textit{lowerSum}$，否则将 $\\textit{nums}[i]$ 加入 $\\textit{upper}$ 中，更新 $\\textit{upperSum}$，此时条件 $1$ 依旧满足。然后我们需要调整优先队列的元素数目关系，以满足条件 $2$： 如果 $n_\\textit{lower} \\gt n_\\textit{upper}$ ，那么将 $\\textit{lower}$ 的最大值移动到 $\\textit{upper}$，同时更新 和 $\\textit{upperSum}$。 如果 $n_\\textit{lower} \\lt n_\\textit{upper}$ ，那么将 $\\textit{upper}$ 的最小值移动到 $\\textit{lower}$，同时更新 $\\textit{lowerSum}$ 和 $\\textit{upperSum}$。 那么： 当 $i+1$ 为偶数时，令中位数为 $t$，那么有 $\\max(\\textit{lower}) \\le t \\le \\min(\\textit{upper})$，从而 $\\textit{res}i = \\sum{j=0}^{i}|\\textit{nums}[j] - t| = \\textit{upperSum} - \\textit{lowerSum}$。 当 $i+1$ 为奇数时，中位数 $t = \\max(\\textit{lower})$，$\\textit{res}i = \\sum{j=0}^{i}|\\textit{nums}[j] - t| = \\textit{upperSum} - \\textit{lowerSum} + \\max(\\textit{lower})$。 返回结果数组 $\\textit{res}$ 即可。 类似的求解中位数的题目有 295. 数据流的中位数 ","date":"2024-02-01","objectID":"/%E5%8A%9B%E6%89%A3-lcp-24-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/:2:0","tags":["数组","数学","堆（优先队列）"],"title":"力扣 LCP 24 数字游戏","uri":"/%E5%8A%9B%E6%89%A3-lcp-24-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"代码 class Solution: def numsGame(self, nums: List[int]) -\u003e List[int]: n = len(nums) res = [0] * n lower, upper = [], [] lowerSum, upperSum = 0, 0 mod = int(1e9 + 7) for i in range(n): x = nums[i] - i if len(lower) == 0 or -lower[0] \u003e= x: lowerSum += x heappush(lower, -x) if len(lower) \u003e len(upper) + 1: upperSum -= lower[0] heappush(upper, -lower[0]) lowerSum += heappop(lower) else: upperSum += x heappush(upper, x) if len(lower) \u003c len(upper): lowerSum += upper[0] heappush(lower, -upper[0]) upperSum -= heappop(upper) if (i + 1) % 2 == 0: res[i] = (upperSum - lowerSum) % mod else: res[i] = (upperSum - lowerSum - lower[0]) % mod return res ","date":"2024-02-01","objectID":"/%E5%8A%9B%E6%89%A3-lcp-24-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/:3:0","tags":["数组","数学","堆（优先队列）"],"title":"力扣 LCP 24 数字游戏","uri":"/%E5%8A%9B%E6%89%A3-lcp-24-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"自由之路 ","date":"2024-01-29","objectID":"/%E5%8A%9B%E6%89%A3-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/:0:0","tags":["深度优先搜索","广度优先搜索","字符串","动态规划"],"title":"力扣 514 自由之路","uri":"/%E5%8A%9B%E6%89%A3-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"},{"categories":["算法"],"content":"题目 电子游戏“辐射4”中，任务 “通向自由” 要求玩家到达名为 “Freedom Trail Ring” 的金属表盘，并使用表盘拼写特定关键词才能开门。 给定一个字符串 ring ，表示刻在外环上的编码；给定另一个字符串 key ，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。 最初，ring 的第一个字符与 12:00 方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。 旋转 ring 拼出 key 字符 key[i] 的阶段中： 您可以将 ring 顺时针或逆时针旋转 一个位置 ，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。 如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。 示例 1： 输入: ring = \"godding\", key = \"gd\" 输出: 4 解释: 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring \"godding\" 2步使它变成 \"ddinggo\"。 当然, 我们还需要1步进行拼写。 因此最终的输出是 4。 示例 2: 输入: ring = \"godding\", key = \"godding\" 输出: 13 提示： 1 \u003c= ring.length, key.length \u003c= 100 ring 和 key 只包含小写英文字母 保证 字符串 key 一定可以由字符串 ring 旋转拼出 ","date":"2024-01-29","objectID":"/%E5%8A%9B%E6%89%A3-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/:1:0","tags":["深度优先搜索","广度优先搜索","字符串","动态规划"],"title":"力扣 514 自由之路","uri":"/%E5%8A%9B%E6%89%A3-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"},{"categories":["算法"],"content":"题解 定义 $\\textit{dp}[i][j]$ 表示从前往后拼写出 $\\textit{key}$ 的第 $i$ 个字符， $\\textit{ring}$ 的第 $j$ 个字符与 12:00 方向对齐的最少步数（下标均从 $0$ 开始）。 显然，只有当字符串 $\\textit{ring}$ 的第 $j$ 个字符需要和 $\\textit{key}$ 的第 $i$ 个字符相同时才能拼写出 $\\textit{key}$ 的第 $i$ 个字符，因此对于 $\\textit{key}$ 的第 $i$ 个字符，需要考虑计算的 $\\textit{ring}$ 的第 $j$ 个字符只有 $\\textit{key}[i]$ 在 $r\\textit{ring}$ 中出现的下标集合。我们对每个字符维护一个位置数组 $\\textit{pos}[i]$，表示字符 $i$ 在 $\\textit{ring}$ 中出现的位置集合，用来加速计算转移的过程。 对于状态 $\\textit{dp}[i][j]$，需要枚举上一次与 12:00 方向对齐的位置 $k$，因此可以列出如下的转移方程： $$ \\textit{dp}[i][j]=\\min_{k \\in pos[key[i-1]]}{dp[i-1][k]+\\min{\\text{abs}(j-k),n-\\text{abs}(j-k)}+1} $$ 其中 $\\min{\\text{abs}(j-k),n-\\text{abs}(j-k)}+1$ 表示在当前第 $k$ 个字符与 12:00 方向对齐时第 $j$ 个字符旋转到 12:00 方向并按下拼写的最少步数。 最后答案即为 $\\min_{i=0}^{n-1}{\\textit{dp}[m-1][i]}$ 这样的做法需要开辟 $O(mn)$ 的空间来存放 $\\textit{dp}$ 值。考虑到每次转移状态 $\\textit{dp}[i][]$ 只会从 $\\textit{dp}[i-1][]$ 转移过来，因此我们可以利用滚动数组优化第一维的空间复杂度，有能力的读者可以尝试实现。下面只给出最朴素的 $O(mn)$ 空间复杂度的实现。 ","date":"2024-01-29","objectID":"/%E5%8A%9B%E6%89%A3-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/:2:0","tags":["深度优先搜索","广度优先搜索","字符串","动态规划"],"title":"力扣 514 自由之路","uri":"/%E5%8A%9B%E6%89%A3-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"},{"categories":["算法"],"content":"代码 class Solution: def findRotateSteps(self, ring: str, key: str) -\u003e int: n, m = len(ring), len(key) pos = [[] for _ in range(26)] for i in range(n): pos[ord(ring[i]) - ord('a')].append(i) dp = [[0x3f3f3f3f for _ in range(n)] for _ in range(m)] for i in pos[ord(key[0]) - ord('a')]: dp[0][i] = min(i, n - i) + 1 for i in range(1, m): for j in pos[ord(key[i]) - ord('a')]: for k in pos[ord(key[i - 1]) - ord('a')]: dp[i][j] = min(dp[i][j], dp[i - 1][k] + min(abs(j - k), n - abs(j - k)) + 1) return min(dp[m - 1]) ","date":"2024-01-29","objectID":"/%E5%8A%9B%E6%89%A3-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/:3:0","tags":["深度优先搜索","广度优先搜索","字符串","动态规划"],"title":"力扣 514 自由之路","uri":"/%E5%8A%9B%E6%89%A3-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"},{"categories":["算法"],"content":"分割数组的最大值 ","date":"2024-01-21","objectID":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/:0:0","tags":["贪心","数组","二分查找","动态规划","前缀和"],"title":"力扣 410 分割数组的最大值","uri":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["算法"],"content":"题目 给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组。 设计一个算法使得这 k 个子数组各自和的最大值最小。 示例 1： 输入：nums = [7,2,5,10,8], k = 2 输出：18 解释： 一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 示例 2： 输入：nums = [1,2,3,4,5], k = 2 输出：9 示例 3： 输入：nums = [1,4,4], k = 3 输出：4 提示： 1 \u003c= nums.length \u003c= 1000 0 \u003c= nums[i] \u003c= 106 1 \u003c= k \u003c= min(50, nums.length) ","date":"2024-01-21","objectID":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/:1:0","tags":["贪心","数组","二分查找","动态规划","前缀和"],"title":"力扣 410 分割数组的最大值","uri":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["算法"],"content":"题解 ","date":"2024-01-21","objectID":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/:2:0","tags":["贪心","数组","二分查找","动态规划","前缀和"],"title":"力扣 410 分割数组的最大值","uri":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["算法"],"content":"方法一：动态规划 思路与算法 「将数组分割为 $m$ 段，求……」是动态规划题目常见的问法。 本题中，我们可以令 $f[i][j]$ 表示将数组的前 $i$ 个数分割为 $j$ 段所能得到的最大连续子数组和的最小值。在进行状态转移时，我们可以考虑第 $j$ 段的具体范围，即我们可以枚举 $k$，其中前 $k$ 个数被分割为 $j−1$ 段，而第 $k+1$ 到第 $i$ 个数为第 $j$ 段。此时，这 $j$ 段子数组中和的最大值，就等于 $f[k][j−1]$ 与 $\\textit{sub}(k+1, i)$ 中的较大值，其中 $\\textit{sub}(i,j)$ 表示数组 $\\textit{nums}$ 中下标落在区间 $[i,j]$ 内的数的和。 由于我们要使得子数组中和的最大值最小，因此可以列出如下的状态转移方程： $$ f[i][j] = \\min_{k=0}^{i-1} \\Big{ \\max(f[k][j-1], \\textit{sub}(k+1,i)) \\Big} $$ 对于状态 $f[i][j]$，由于我们不能分出空的子数组，因此合法的状态必须有 $i \\geq j$。对于不合法（$i\u003cj$）的状态，由于我们的目标是求出最小值，因此可以将这些状态全部初始化为一个很大的数。在上述的状态转移方程中，一旦我们尝试从不合法的状态 $f[k][j−1]$ 进行转移，那么 $\\max(\\cdots)$ 将会是一个很大的数，就不会对最外层的 $\\min{\\cdots}$ 产生任何影响。 此外，我们还需要将 $f[0][0]$ 的值初始化为 $0$。在上述的状态转移方程中，当 $j=1$ 时，唯一的可能性就是前 $i$ 个数被分成了一段。如果枚举的 $k=0$，那么就代表着这种情况；如果 $k \\neq 0$，对应的状态 $f[k][0]$ 是一个不合法的状态，无法进行转移。因此我们需要令 $f[0][0] = 0$。 最终的答案即为 $f[n][m]$。 ","date":"2024-01-21","objectID":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/:2:1","tags":["贪心","数组","二分查找","动态规划","前缀和"],"title":"力扣 410 分割数组的最大值","uri":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["算法"],"content":"方法二：二分查找 + 贪心 思路及算法 「使……最大值尽可能小」是二分搜索题目常见的问法。 本题中，我们注意到：当我们选定一个值 $x$，我们可以线性地验证是否存在一种分割方案，满足其最大分割子数组和不超过 $x$。策略如下： 贪心地模拟分割的过程，从前到后遍历数组，用 $\\textit{sum}$ 表示当前分割子数组的和，$\\textit{cnt}$ 表示已经分割出的子数组的数量（包括当前子数组），那么每当 $\\textit{sum}$ 加上当前值超过了 $x$，我们就把当前取的值作为新的一段分割子数组的开头，并将 $\\textit{cnt}$ 加 $1$。遍历结束后验证是否 $\\textit{cnt}$ 不超过 $m$。 这样我们可以用二分查找来解决。二分的上界为数组 $\\textit{nums}$ 中所有元素的和，下界为数组 $\\textit{nums}$ 中所有元素的最大值。通过二分查找，我们可以得到最小的最大分割子数组和，这样就可以得到最终的答案了。 ","date":"2024-01-21","objectID":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/:2:2","tags":["贪心","数组","二分查找","动态规划","前缀和"],"title":"力扣 410 分割数组的最大值","uri":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["算法"],"content":"代码 方法一：动态规划 class Solution { public int splitArray(int[] nums, int m) { int n = nums.length; int[][] f = new int[n + 1][m + 1]; for (int i = 0; i \u003c= n; i++) { Arrays.fill(f[i], Integer.MAX_VALUE); } int[] sub = new int[n + 1]; for (int i = 0; i \u003c n; i++) { sub[i + 1] = sub[i] + nums[i]; } f[0][0] = 0; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= Math.min(i, m); j++) { for (int k = 0; k \u003c i; k++) { f[i][j] = Math.min(f[i][j], Math.max(f[k][j - 1], sub[i] - sub[k])); } } } return f[n][m]; } } 方法二：二分查找 + 贪心 class Solution { public int splitArray(int[] nums, int m) { int left = 0, right = 0; for (int i = 0; i \u003c nums.length; i++) { right += nums[i]; if (left \u003c nums[i]) { left = nums[i]; } } while (left \u003c right) { // 这里的二分中值取 mid = (right - left) / 2 + left 是为了防止 (left + right) / 2 的计算结果溢出整型范围。 int mid = (right - left) / 2 + left; if (check(nums, mid, m)) { right = mid; } else { left = mid + 1; } } return left; } public boolean check(int[] nums, int x, int m) { int sum = 0; int cnt = 1; for (int i = 0; i \u003c nums.length; i++) { if (sum + nums[i] \u003e x) { cnt++; sum = nums[i]; } else { sum += nums[i]; } } return cnt \u003c= m; } } ","date":"2024-01-21","objectID":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/:3:0","tags":["贪心","数组","二分查找","动态规划","前缀和"],"title":"力扣 410 分割数组的最大值","uri":"/%E5%8A%9B%E6%89%A3-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["算法"],"content":"使数组和小于等于x的最少时间 ","date":"2024-01-19","objectID":"/%E5%8A%9B%E6%89%A3-2809-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/:0:0","tags":["数组","动态规划","排序"],"title":"力扣 2809 使数组和小于等于x的最少时间","uri":"/%E5%8A%9B%E6%89%A3-2809-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/"},{"categories":["算法"],"content":"题目 给你两个长度相等下标从 0 开始的整数数组 nums1 和 nums2 。每一秒，对于所有下标 0 \u003c= i \u003c nums1.length ，nums1[i] 的值都增加 nums2[i] 。操作 完成后 ，你可以进行如下操作： 选择任一满足 0 \u003c= i \u003c nums1.length 的下标 i ，并使 nums1[i] = 0 。 同时给你一个整数 x 。 请你返回使 nums1 中所有元素之和 小于等于 x 所需要的 最少 时间，如果无法实现，那么返回 -1 。 示例 1： 输入：nums1 = [1,2,3], nums2 = [1,2,3], x = 4 输出：3 解释： 第 1 秒，我们对 i = 0 进行操作，得到 nums1 = [0,2+2,3+3] = [0,4,6] 。 第 2 秒，我们对 i = 1 进行操作，得到 nums1 = [0+1,0,6+3] = [1,0,9] 。 第 3 秒，我们对 i = 2 进行操作，得到 nums1 = [1+1,0+2,0] = [2,2,0] 。 现在 nums1 的和为 4 。不存在更少次数的操作，所以我们返回 3 。 示例 2： 输入：nums1 = [1,2,3], nums2 = [3,3,3], x = 4 输出：-1 解释：不管如何操作，nums1 的和总是会超过 x 。 提示： 1 \u003c= nums1.length \u003c= 103 1 \u003c= nums1[i] \u003c= 103 0 \u003c= nums2[i] \u003c= 103 nums1.length == nums2.length 0 \u003c= x \u003c= 106 ","date":"2024-01-19","objectID":"/%E5%8A%9B%E6%89%A3-2809-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/:1:0","tags":["数组","动态规划","排序"],"title":"力扣 2809 使数组和小于等于x的最少时间","uri":"/%E5%8A%9B%E6%89%A3-2809-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/"},{"categories":["算法"],"content":"题解 首先，我们可以发现，每一次操作使得 $nums_1[i]=0$，对于每一个 $nums_1[i]$ 我们最多需要进行一次这样的操作。如果我们需要设置两次，我们可以简单地移除前一次设置。 观察重置为零的数，会按照 $nums_2$ 的速度增长，所以对于所有操作的数，我们应该优先操作增长速度慢的数。 如果我们选择多个索引 $i_1,i_2,\\cdots, i_k$ ，那么按照 $\\textit{nums}_2[i_1] \\le \\textit{nums}_2[i_2] \\le \\cdots \\le \\textit{nums}_2[i_k]$ 的顺序进行设置是最优的。 让我们按照 $nums_2$ 的大小对所有数值对进行排序（非递减顺序）。用 $dp[j][i]$ 表示如果对前 $j$ 个元素进行 $i$ 次操作，可以减少的最大总值，初始值为零。对于第 $j$ 个元素，我们可以选择对其进行操作或者不操作，由此可以得到状态转移方程： $$ \\textit{dp}[j][i] = \\max(\\textit{dp}[j - 1][i], \\textit{dp}[j - 1][i - 1] + \\textit{nums}_2[j - 1] \\times i + \\textit{nums}_1[j - 1]) $$ 其中有 $1 \\le i \\le j \\le n$。 最后我们返回最小的 $t$，使满足 $\\textit{sum}(\\textit{nums}_1) + \\textit{sum}(\\textit{nums}_2) \\times t - \\textit{dp}[n][t] \\le x$，如果不存在返回 $-1$。 ","date":"2024-01-19","objectID":"/%E5%8A%9B%E6%89%A3-2809-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/:2:0","tags":["数组","动态规划","排序"],"title":"力扣 2809 使数组和小于等于x的最少时间","uri":"/%E5%8A%9B%E6%89%A3-2809-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/"},{"categories":["算法"],"content":"代码 class Solution { public int minimumTime(List\u003cInteger\u003e nums1, List\u003cInteger\u003e nums2, int x) { int n = nums1.size(), s1 = 0, s2 = 0; int[][] dp = new int[n + 1][n + 1]; int[][] nums = new int[n][2]; for (int i = 0; i \u003c n; i++) { int a = nums1.get(i), b = nums2.get(i); nums[i][0] = b; nums[i][1] = a; s1 += a; s2 += b; } Arrays.sort(nums, Comparator.comparingInt(o -\u003e o[0])); for (int j = 1; j \u003c= n; ++j) { int b = nums[j - 1][0], a = nums[j - 1][1]; for (int i = j; i \u003e 0; --i) { dp[j][i] = Math.max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a); } } for (int i = 0; i \u003c= n; i++) { if (s2 * i + s1 - dp[n][i] \u003c= x) { return i; } } return -1; } } 在上面的方法中，$dp[i]$ 的状态只和 $dp[i−1]$ 有关。 所以我们可以省去第一个维度，从而优化空间，从 $O(n^2)$ 优化到 $O(n)$，其中 $n$ 是输入数组的长度。 class Solution { public int minimumTime(List\u003cInteger\u003e nums1, List\u003cInteger\u003e nums2, int x) { int n = nums1.size(), s1 = 0, s2 = 0; int[] dp = new int[n + 1]; List\u003cList\u003cInteger\u003e\u003e nums = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c n; i++) { int a = nums1.get(i), b = nums2.get(i); nums.add(Arrays.asList(b, a)); s1 += a; s2 += b; } Collections.sort(nums, (o1, o2) -\u003e Integer.compare(o1.get(0), o2.get(0))); for (int j = 1; j \u003c= n; ++j) { int b = nums.get(j - 1).get(0), a = nums.get(j - 1).get(1); for (int i = j; i \u003e 0; --i) { dp[i] = Math.max(dp[i], dp[i - 1] + i * b + a); } } for (int i = 0; i \u003c= n; i++) { if (s2 * i + s1 - dp[i] \u003c= x) { return i; } } return -1; } } ","date":"2024-01-19","objectID":"/%E5%8A%9B%E6%89%A3-2809-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/:3:0","tags":["数组","动态规划","排序"],"title":"力扣 2809 使数组和小于等于x的最少时间","uri":"/%E5%8A%9B%E6%89%A3-2809-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/"},{"categories":["算法"],"content":"拿出最少数目的魔法豆 ","date":"2024-01-18","objectID":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/:0:0","tags":["贪心","排序","数学"],"title":"力扣 2171 拿出最少数目的魔法豆","uri":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/"},{"categories":["算法"],"content":"题目 给定一个 正整数 数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。 请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少还有一颗 魔法豆的袋子）魔法豆的数目 相等。一旦把魔法豆从袋子中取出，你不能再将它放到任何袋子中。 请返回你需要拿出魔法豆的 最少数目。 示例 1： 输入：beans = [4,1,6,5] 输出：4 解释： - 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。 剩下袋子中魔法豆的数目为：[4,0,6,5] - 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,5] - 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,4] 总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 4 个魔法豆更少的方案。 示例 2： 输入：beans = [2,10,3,2] 输出：7 解释： - 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,2] - 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,0] - 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,0,0] 总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 7 个魔法豆更少的方案。 提示： 1 \u003c= beans.length \u003c= 105 1 \u003c= beans[i] \u003c= 105 ","date":"2024-01-18","objectID":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/:1:0","tags":["贪心","排序","数学"],"title":"力扣 2171 拿出最少数目的魔法豆","uri":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/"},{"categories":["算法"],"content":"题解 寻找某一个数字 $x$，当我们将豆子数量小于 $x$ 的袋子清空，并将豆子数量大于 $x$ 的袋中豆子数量变为 $x$ 时，拿出的豆子数量最少。 那么，$x$ 一定等于某一个袋子的豆子数。 证明 我们可以用反证法来证明上述命题。当 $x$ 不等于某一个袋子的豆子数时，我们可以分两种情况讨论： $x$ 大于最多袋子的豆子数：不妨设最多的袋子豆子数为 $y$，所有袋子豆子总数为 $total$，则： $x$ 对应拿出的豆子数为 $total$； $y$ 对应拿出的豆子数为 $total−y×n_y$ ，其中 $n_y\u003e1$ 为豆子数为 $y$ 的袋子数量。 $x$ 小于最多袋子的豆子数：假设豆子数量大于 $x$ 的袋子中最小的豆子数量为 $y$，所有袋子豆子总数为 $total$，则： $x$ 对应拿出的豆子数为 $total - x \\times n_x$ ，其中 $n_x\u003e1$ 为豆子数大于等于 $x$ 的袋子数量； $y$ 对应拿出的豆子数为 $total - y \\times n_y$ ，其中 $n_y=n_x$ 为豆子数大于等于 $y$ 的袋子数量。 对于上述两种情况而言，都存在至少一种等于某个袋子豆子数的情况，对应拿出的豆子数更低。 思路与算法 我们不妨设 $beans$ 数组的长度为 $n$。最少的豆子数量即为： $$ \\min_{x \\in \\textit{beans}} (\\textit{total} - x \\times n_x). $$ 容易发现，对于每一个 $x$，都需要 $O(n)$ 的时间复杂度计算豆子数大于等于 $x$ 的袋子数量 $n_x$ ，那么总时间复杂度为 $O(n^2)$，不符合题目要求。因此我们需要简化计算 $n_x$ 的时间复杂度。 我们可以对 $\\textit{beans}$ 数组升序排序。那么对于排序后数组下标为 $i$ 的元素，对应的 $n_x$ 即为 $n-i$。这样一来，我们只需要 $O(1)$ 的时间复杂度就可以计算出上文的每个 $n_x$。与此同时，上式变为： $$ \\min_{0 \\le i \u003c n} (\\textit{total} - \\textit{beans}[i] \\times (n - i)). $$ 那么，我们只需要遍历排序后的 $\\textit{beans}$ 数组，并维护上式的最小值，最终将最小值返回作为答案即可。 ","date":"2024-01-18","objectID":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/:2:0","tags":["贪心","排序","数学"],"title":"力扣 2171 拿出最少数目的魔法豆","uri":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/"},{"categories":["算法"],"content":"代码 class Solution { public long minimumRemoval(int[] beans) { int n = beans.length; Arrays.sort(beans); long total = 0; // 豆子总数 for (int i = 0; i \u003c n; i++) { total += beans[i]; } long res = total; // 最少需要移除的豆子数 for (int i = 0; i \u003c n; i++) { res = Math.min(res, total - (long) beans[i] * (n - i)); } return res; } } ","date":"2024-01-18","objectID":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/:3:0","tags":["贪心","排序","数学"],"title":"力扣 2171 拿出最少数目的魔法豆","uri":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/"},{"categories":["算法"],"content":"细节 在计算最小值的过程中，$total$ 和 $beans[i]×(n−i)$ 都有可能超过 32 位有符号整数的上界，因此对于 C++ 等语言，我们需要使用 64 位整数来维护并计算上述变量与最小值。 ","date":"2024-01-18","objectID":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/:4:0","tags":["贪心","排序","数学"],"title":"力扣 2171 拿出最少数目的魔法豆","uri":"/%E5%8A%9B%E6%89%A3-2171-%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86/"},{"categories":["信息安全"],"content":"第一章 整除 $\\forall a,b,c \\in Z$ $a|b,b|c \\implies a|c$ $a|b,a|c \\iff \\forall x,y \\in Z ,a|bx+cy$ $m\\neq 0 ,a|b \\iff ma|mb$ $a|b,b|a \\implies a=\\pm b$ $\\exist a,b \\in Z,a\\neq 0 \\implies \\exist_{=1} q,r\\in Z ,0\\le r \u003c |a|,b=aq+r$ $\\forall a,b,c \\in Z$ $gcd(a,b)=gcd(b,a)=gcd(-a,b)=gcd(a,-b)$ $a|b \\implies gcd(a,b)=a$ $\\forall a,b\\in Z,gcd (a,b)|ax+by$ $\\forall a,b\\in Z ,\\exist x,y \\in Z ,gcd(a,b)=xa+yb$ $\\exist a,b,c,q\\in Z ,a=bq+c\\implies gcd (a,b)=gcd(b,c)$ $gcd \\left ( \\frac{a}{gcd(a,b)},\\frac{b}{gcd(a,b)} \\right)=1$ $\\exist a,b,m \\in Z,a|m,b|m \\implies lcm[a,b]|m$ 辗转相除法 $\\exist a,b,c,q\\in Z ,a=bq+c\\implies gcd (a,b)=gcd(b,c)$ 当 $a,b$中有负整数时，可将其中的负整数转变为正整数来求其最大公因数。 $\\forall a,b\\in Z ,\\exist x,y \\in Z ,gcd(a,b)=xa+yb$ 设 $a,b$ 是两个不全为 0 的整数，$gcd(a,b)=1\\iff \\exist u,v \\in Z ,ua+vb=1$ $\\exist a,b,c \\in Z^+$ $c|ab,gcd(a,c)=1\\implies c|b$ $a|c,b|c,gcd(a,b)=1 \\implies ab|c$ $gcd(a,c)=1,gcd(b,c)=1 \\implies gcd(ab,c)=1$ $\\exist a,b \\in Z^+$ 若 $a,b$ 互素 $\\implies lcm[a,b]=ab$ $lcm[a,b]=\\frac {ab}{gcd(a,b)}$ $\\exist p \\in P,\\exist a,b \\in Z$ $p \\nmid a \\implies $ $p$ 与 $a$ 互素 $p|a_1a_2\\cdots a_k \\implies \\exist p|a_i$ 算数基本定理 $\\forall n \\in Z^+-{0,1} $可唯一表示为$n=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k}$ 素数有无穷多个 Eratosthenes筛法 设 $n$ 是一个正合数，$p$ 是 $n$ 的大于1的最小正因数，则 $p$ 是素数且 $p\\leq \\sqrt{n}$ 设 $n$ 是一个正整数。如果对于所有的素数 $p\\leq \\sqrt{n}$ ，都 有 $p\\nmid n$ ，则 $n$ 是素数 Mersenne 素数 设 $n\\geq1$ 是一个正整数，若 $a^n-1$ 是素数，则 $a=2,n$ 是素数 如果 $b\\ge 2$ 为整数，那么任意正整数 $n$ 都可以唯一表示为 $$ a=a_nb^n+a_{n-1}b^{n-1}+\\cdots + a_1b+a_0(b^0) $$ 其中 $a_i$ 是整数，$0\\le a_i \u003c b,0\\leq i\\le n,a_n\\neq 0$。以 $b$ 为基，或 $b$ 进制。 正整数 的以 为基的表示通常可写成 $$ a=(a_na_{n-1}\\cdots a_1a_0)_b $$ ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B4%E9%99%A4/:0:0","tags":["初等数论"],"title":"信息安全数学基础 第一章 整除","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B4%E9%99%A4/"},{"categories":["信息安全"],"content":"第七章 椭圆曲线 $GF(p)$ 上的椭圆曲线 $$ E={(x,y)\\in GF(p) \\times GF(p)|y^2=x^3+ax+b \\ (mod \\ p),4a^3+27b^2 \\not\\equiv 0 \\ (mod \\ p) } \\cup {O} $$ 椭圆曲线约束方程 $4a^3+27b^2 \\not\\equiv 0 \\ (mod \\ p)$ 单位元，无穷远点 $O$ 逆元，$(x,-y)$ $GF(p)$ 上椭圆曲线几何加法 $P+O=P,O+P=P$ $O=-O$ $P=(x_1,y_1) \\neq O \\implies -P=(x_1,-y_1)$ $Q=-P \\implies P+Q=O$ $P \\neq O,Q \\neq O,P \\neq Q \\implies P+Q+R^\\prime =O, P+Q=R$ 域 $K$ 上的椭圆曲线 $E$ ，$(E(K),+)$ 是商群 $(E/K,+)$ 的子群 椭圆曲线 $E_1/K$ 和 $E_2/K$ 同构 $\\implies$ 群到群是同构的 $GF(p)$ 上椭圆曲线 $y^2=x^3+ax+b \\ (mod \\ p)$ 代数加法 $P=(x_1,y_1),Q=(x_2,y_2),R=(x_3,y_3),P+Q=R$ 斜率 $\\lambda$ $$ \\lambda =\\left{ \\begin{align} \u0026\\frac{y_2-y_1}{x_2-x_1}(P \\neq Q,P \\neq -Q) \\ \u0026\\frac{3x_1^2+a}{2y_1}(P=Q) \\end{align} \\right. $$ 性质 $$ \\left{ \\begin{align} \u0026x_1+x_2+x_3= \\lambda^2 \\ \u0026y_3=-(\\lambda(x_3-x_1)+y_1)=-(\\lambda(x_3-x_2)+y_2) \\end{align} \\right. $$ $R=(\\lambda^2-x_1-x_2, \\lambda(x_1-x_3)-y_1)$ 标量乘法 $nP=P+P+ \\cdots + P$ $2P=P+P,4P=2P+2P,8P=4P+4P \\implies 5P=4P+P$ $GF(p^m)$ 上椭圆曲线加法群的阶 $#E(K)$ $#E(K) \\leq 2p^m+1,#E(k) \\approx p^m$ 存在 $#E(K)=q+1-t$ 的充分必要条件 $t \\not\\equiv 0 \\ (mod \\ p),t^2 \\leq 4p^m$ $m$ 是奇数，且下面任意条件成立 $t=0$ $t^2=2p^m,p=2$ $t^2=3p^m,p=3$ $m$ 是偶数，且下面任意条件成立 $t^2=4p^m$ $t^2=p^m,p \\not\\equiv1 \\ (mod \\ 3)$ $t^2=p^m,p \\not\\equiv1 \\ (mod \\ 4)$ $p\u003e3,a,b \\in GF(p)\\implies #E_p(a,b)=1+\\sum^{p-1}_{x=0}[(\\frac{x^3+ax+b}{p})+1]$ Legendre符号 $\\left(\\frac{a}{p}\\right)=a^{\\frac{p-1}{2}}\\ mod p$ $p\u003e3,p \\equiv 3 \\ mod \\ 4,\\forall a \\in GF(p)^* \\implies #E_p(a,0)=p+1$ $p\u003e3,p \\equiv 2 \\ mod \\ 3,\\forall a \\in GF(p)^* \\implies #E_p(0,b)=p+1$ ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/:0:0","tags":["抽象代数"],"title":"信息安全数学基础 第七章 椭圆曲线","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/"},{"categories":["信息安全"],"content":"Elgamal公钥加密 密钥生成 $P \\in E_p(a,b),o(P)=n$ $x,1 \u003c x\u003cn$ $Q=xP$ 加密 $k,1\u003ck\u003cn$ $C=(C_1=kP,C_2=P_m+kQ)$ 解密 $C_2-xC_1=P_m+kQ-xkP=P_m$ ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/:1:0","tags":["抽象代数"],"title":"信息安全数学基础 第七章 椭圆曲线","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/"},{"categories":["信息安全"],"content":"第三章 群 群 满足结合律 $(a \\circ b)\\circ c=a \\circ (b\\circ c)$ 有单位元 $e$ 有逆元 $a^{-1}$ （运算封闭） 群 $G$ 的性质 $a\\in G,e \\circ a=a \\circ e =a$ $\\forall a \\in G,\\exist_{=1} b \\in G,ab=ba=e$ $\\forall a,b,c,ab=ac \\implies b=c$ $\\forall a,b \\in G$ $ax=b$ 解唯一 $xa=b$ 解唯一 $\\forall a,b \\in G , (ab)^{-1}=b^{-1}a^{-1}$ 集合 $G$ 非空，乘法封闭，满足结合律，$\\forall a,b \\in G,ax=b，ya=b$ 在 $G$ 中有解 $\\implies G$ 是群 有限集合 $G$ ，乘法封闭，满足结合律，满足消去律 $\\implies G$ 是群 子群 如果群 $G$ 的非空子集合 $H$ 对于 $G$ 中的运算也构成一个群，那么称 $H$ 为 $G$ 的子群，记为 $H \\leq G$ 。 在群 $G$ 中，仅有单位元素构成的子集合 ${e}$ 和 $G$ 本身显然都是 $G$ 的子群。（平凡子群） 群 $G$ 和 子群 $H \\leq G$ $e_G=e_H$ $\\forall a,a^{-1} \\in G,a\\ \\in H \\implies a^{-1} \\in H$ $a^na^m=a^{m+n},(a^n)^m=a^{mn}$ $na+ma=(n+m)a,(na)m=mna$ 群 $G,\\forall a \\in G$，由 $a$ 生成的子群$H=\\langle a \\rangle ={a^i|i \\in Z } , H\\leq G$ $a^k=e$，最小正整数 $k$ 为元素 $a$ 的阶 $o(a)$ $a^{|G|}=e$ 同时易得 $|\\langle a \\rangle|=o(a)$ $H$ 是循环群，$a$ 是生成元 群 $G$，非空子集合 $H$ $\\forall a,b \\in H,ab^{-1} \\in H \\iff H \\leq G$ 群 $G$ ，子群 $H$ ，$\\forall a \\in G$，左陪集 $aH$ ，右陪集 $Ha$，等价关系 $R_H=\\sim$ $aH={ah|h \\in H},a \\in aH,|aH|=|H|$ （$Ha$同） $aG=G,GG={ah|h\\in G,a \\in G}=G$ $a\\sim b \\iff b^{-1}a \\in H $ $[a]_{R_H}=aH$ $H$ 的任意两个陪集或者相等或者无公共元素 群 $G$ 可以表示成 $H$ 的若干个不相交的陪集之并 $H$ 的左陪集的个数称为 $H$ 在 $G$ 中的指数，记为 $[G:H]$ $|G|=|H||G:H|$ $aH=Ha \\iff H \\lhd G$ 交换群的所有子群都是正规子群 有限群 $G,\\forall a \\in G \\implies o(a),|, |G|$ 欧拉定理 $\\exist m \\in Z^+,r\\in Z_m ,gcd(r,m)=1 \\implies r^{\\varphi(m)}\\equiv 1(mod \\ m)$ $gcd(r,m)=1 \\implies r \\in Z^*_m$ $Z^*_m$ 是群 $Z^*_m=\\varphi(m)$ 群的中心是指群中所有与其他元素都满足交换律的元素组成的集合，用C(G)表示。群的中心是群的一个子群，也是一个正规子群 群 $G$ ，子群$H\\leq G,a^{-1}Ha={a^{-1}ha|h \\in H},\\forall a \\in G $ $\\iff H \\lhd G$ $\\iff aH=Ha$ $\\iff \\forall h \\in H,a^{-1}ha \\in H$ $\\iff a^{-1}Ha \\subseteq H$ $\\iff a^{-1}Ha = H$ 群 $G$ ，正规子群 $H \\lhd G$ 商群 $G/H={aH|a \\in G}$ $(aH)(bH)=(ab)H$ $G/H$ 同时也是群 单位元 $H$ $aH$ 逆元 $a^{-1}H$ 群 $G,G^\\prime,f:G\\to G^\\prime,\\forall a,b\\in G$ 映射满足 $$ f(a)f(b)=f(ab) $$ 则称 $f$ 是群 $G$ 到 $G^\\prime$ 的一个同态映射。 $f$ 是满射，满同态映射，$e \\to e^\\prime,a^{-1} \\to {a^{-1}}^\\prime$ $f$ 是一一映射，同构映射 $G \\cong G^\\prime$，内自同构 $G \\cong G$ $G$ 与 $G/H$ 同态 （自然同态） 同态 $f$ 的象 $f(G)={f(a)|a \\in G}$ $\\forall a^\\prime \\in G ,a^\\prime$ 的完全逆象 $f^{-1}(a^\\prime)={a \\in G| f(a)=a^\\prime }$ 同态 $f$ 的核 $ker(f)=f^{-1}(e^\\prime)$ 群同态基本定理 群 $G,G^\\prime $，满同态映射$f:G \\to G^\\prime,N=ker(f) \\implies N\\lhd G,G^\\prime \\cong G/N$ $G=\\langle a \\rangle$ 是无限循环群 $\\implies G$ 只有两个生成元 $a,a^{-1}$ 设 $G=\\langle a \\rangle$ 是 $n$ 阶循环群，显然 $o(a)=n$，则群 $G$ 中的元素都是 $a^k$ 的形式，其中 $gcd(k,n)=1$ $a^j$ 是 $G$ 的生成元 $\\iff gcd(j,n)=1$ $\\forall m \\in Z^+ ,a^m=e \\iff n|m$ $\\forall k \\in Z^+,o(a^k)=\\frac {n}{gcd(k,n)}$ 设 $\\alpha \\in Z^_m$ ，若 $o(\\alpha)=\\varphi(m)$ ，则 $\\alpha$ 称为 $Z^_m$ 的生成元或原根。 $Z^_m$ 是循环群，$Z^_m={\\alpha ^i (mod \\ m)|0 \\leq i \\leq \\varphi(n)-1 }$ $\\beta \\equiv \\alpha ^i (mod \\ m)$ 为 $Z^*_m$ 的生成元 $\\iff gcd(i,\\varphi (m))=1$ $Z^*_m$ 的生成元个数为 $\\varphi(\\varphi(m))$ $\\forall p \\in P/{2},k \\in Z^+,m=2,4,p^k,2p^k \\iff Z^*_m$ 有生成元 如果 $p$ 为一素数， 则 $Z^*_p$ 有生成元 循环群的子群是循环群。循环群的商群也是循环群 $G=\\langle a \\rangle $ 是循环群 $o(a)=\\infin \\implies G$与整数加群 $\\langle Z,+ \\rangle$ 同构 $o(a)=m \\in Z^+ \\implies G$与整数模 $m$ 的剩余类加群 $\\langle Z_m,+ \\rangle$ 同构 循环群 $G=\\langle a \\rangle ,\\exist k \\in Z^+,h=a^k \\in G$ $k$ 称为 $h$ 相对于生成元的离散对数 $k=log_a h$ 确定元素 $a$ 的阶 有限群 $G,\\forall a \\in G \\implies o(a),|, |G|$ $|G|=n=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k}$ $o(a)=p_1^{e_1}p_2^{e_2}\\cdots p_k^{e_k} |n,e_i \\leq \\alpha_i$ 求循环群 $G$ 生成元 随机选择 $a \\in G$ $|G|=n=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k}$ $a^{p_1^{\\alpha_1}\\cdots p_2^{\\alpha_i -w}\\cdots p_k^{\\alpha_k}} \\equiv 1 \\implies a^{p_1^{\\alpha_1}\\cdots p_2^{\\alpha_i -w +1}\\cdots p_k^{\\alpha_k}} \\equiv 1 \\implies a^{p_1^{\\alpha_1}\\cdots p_2^{\\alpha_i -1}\\cdots p_k^{\\alpha_k}} \\equiv 1$ 只需要判断 $\\alpha_i -1$即可 $a^{p_1^{\\alpha_1}\\cdots p_2^{\\alpha_i -1}\\cdots p_k^{\\alpha_k}} \\equiv 1 \\implies a$ 不是循环群 $G$ 的生成元 求解 $n$ 阶循环群 $G=\\langle a \\rangle$ 离散对数 $t=log_ah$ 的快速搜索算法 提前计算，中途相遇 $t$ 的带余除法在 $m$ 确定情况下有唯一表达式 $t=q_0m+r_0,t\u003cn$ 遍历 $q,r$ ，直到 $a^{qm+r}=h$ 会反复计算 $a^r$ ，可作一张表 $L={a^r,r},r=0,1,\\cdots ,m-1$ 另一方面，可以计算 $h(","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BE%A4/:0:0","tags":["抽象代数"],"title":"信息安全数学基础 第三章 群","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BE%A4/"},{"categories":["信息安全"],"content":"ElGamal公钥加密 密钥生成 $p \\in P$ $Z^*_p$ 生成元 $g$ $\\alpha \\in Z_{p-1},\\beta=g^\\alpha (mod \\ p)$ 加密 $k \\in Z_{p-1}$ $E(m,k)=(r=g^k \\ mod \\ p,s=m\\beta^k \\ mod \\ p)$ 解密 $D(r,s)=s(r^\\alpha)^{-1} \\ mod \\ p =mg^{ak}g^{-ak} \\ mod \\ p=m$ ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BE%A4/:1:0","tags":["抽象代数"],"title":"信息安全数学基础 第三章 群","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BE%A4/"},{"categories":["信息安全"],"content":"第二章 同余 $a\\equiv b(mod \\ m) \\iff \\exist k \\in Z ,a=km+b$ $a=k_1m+r_1,b=k_2m+r_2,0\\leq r_1 \u003cm,0\\leq r_2 \u003cm,a\\equiv b(mod \\ m ) \\iff r_1=r_2$ $\\exist a,b,c,m \\in Z^+$ 自反性：$a\\equiv a (mod \\ m)$ 对称性：$a\\equiv b(mod \\ m)\\implies b\\equiv a (mod \\ m)$ 传递性：$a\\equiv b(mod \\ m),b\\equiv c(mod \\ m)\\implies a\\equiv c (mod \\ m)$ $\\exist a,b,d,a_1,a_2,b_1,b_2,m \\in Z^+$ $a_1 \\equiv a_2 (mod \\ m),b_1 \\equiv b_2 (mod \\ m)\\implies a_1+b_1 \\equiv a_2+b_2 (mod \\ m)$ $a_1 \\equiv a_2 (mod \\ m),b_1 \\equiv b_2 (mod \\ m)\\implies a_1-b_1 \\equiv a_2-b_2 (mod \\ m)$ $a_1 \\equiv a_2 (mod \\ m),b_1 \\equiv b_2 (mod \\ m)\\implies a_1a_2 \\equiv b_1b_2 (mod \\ m)$ $ad\\equiv bd (mod \\ m) ,(d,m)=1\\implies a \\equiv b(mod \\ m )$ $a \\equiv b(mod \\ m)$，$d$ 是 $a,b,m$ 的任意公因数 $\\implies \\frac ad \\equiv \\frac bd (mod \\ \\frac md)$ $a \\equiv b (mod \\ m ),d|m \\implies a\\equiv b(mod \\ d)$ $a \\equiv b(mod \\ m_i),i=1,2,\\cdots ,k\\implies a \\equiv b (mod \\ lcm [m_1,m_2,\\cdots ,m_k])$ 对于给定的正整数 $m$ ，有且恰有 $m$ 个不同的模 $m$ 的剩余类。 $\\exist m \\in Z^+ ,\\exist a \\in Z,\\forall b \\in Z ,gcd(a,m)=1$，若 $x$ 遍历模 $m$ 的一个完全剩余系，则 $ax+b$ 也 遍历模 $m$ 的一个完全剩余系 $\\exist m_1,m_2 \\in Z^+，gcd(m_1,m_2)=1$，若 $x$ 遍历模 $m_1$ 的一个完全剩余系，$y$ 遍历模 $m_2$ 的一个完全剩余系，则 $m_1y+m_2x$ 也遍历模 $m_1m_2$ 的一个完全剩余系 在模 $m$ 的一个剩余类当中，如果有一个数与 $m$ 互素，则该剩余类中所有的数均与 $m$ 互素，这时称该剩余类与 $m$ 互素。 与 $m$ 互素的剩余类的个数称为欧拉函数，记为 $\\varphi(m)$ 等于 $Z_m$ 当中与 $m$ 互素的数的个数。对于任意一个素数 $p$ ，$\\varphi(m)=p-1$ 。 $\\exist m \\in Z^+ ,\\exist a \\in Z,gcd(a,m)=1$，若 $x$ 遍历模 $m$ 的一个既约剩余系，则 $ax$ 也遍历模 $m$ 的一个既约剩余系 $\\exist m_1,m_2 \\in Z^+，gcd(m_1,m_2)=1$，若 $x$ 遍历模 $m_1$ 的一个既约剩余系，$y$ 遍历模 $m_2$ 的一个既约剩余系，则 $m_1y+m_2x$ 也遍历模 $m_1m_2$ 的一个既约剩余系 $\\exist m,n\\in Z,gcd(m,n)=1 \\implies \\varphi(mn)=\\varphi (m)\\varphi(n)$ $\\exist p_i \\in P,\\exist m=p_1^{e_1}p_2^{e_2}\\cdots p_k^{e_k} \\implies \\varphi(m)=m \\prod^k_{i=1}(1-\\frac1{p_i})$ $\\exist m \\in Z^+,r \\in Z_m,gcd(r,m)=1 \\implies \\exist s \\in Z_m , rs \\equiv 1(mod \\ m)$ 欧拉定理 $\\exist m \\in Z^+,r\\in Z_m ,gcd(r,m)=1 \\implies r^{\\varphi(m)}\\equiv 1(mod \\ m)$ 费马小定理 $\\forall p\\in P,a\\in Z \\implies a^p \\equiv a(mod \\ p)$ Miller–Rabin概率素数测试 $p$ 为素数时，费马小定理成立；$p$ 为合数时，费马小定理不一定成立（不成立则必为合数） $p$ 为奇素数，$x^2 \\equiv 1 (mod \\ p)$ 的解只有 $x\\equiv \\pm 1 (mod \\ p)$ $\\forall p \\in P,r_1,r_2,\\cdots ,r_{p-1} \\in Z^*p \\implies \\prod ^{p-1}{i=1}r_i \\equiv -1\\equiv p-1(mod \\ p)$ ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/:0:0","tags":["初等数论"],"title":"信息安全数学基础 第二章 同余","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/"},{"categories":["信息安全"],"content":"同余方程 一次同余方程 $ax \\equiv b (mod \\ m )$ 有解的充要条件是 $gcd(a,m)|b$ ，而且当其有解时，其解数为 $gcd(a,m)$ 对于一次同余方程 $ax \\equiv b (mod \\ m )$ 设 $a^\\prime = \\frac a {gcd(a,m)},m^\\prime = \\frac m {gcd(a,m)},b^\\prime = \\frac b {gcd(a,m)}$ 考虑 $a^\\prime x \\equiv 1 (mod \\ m^\\prime)$ 有唯一解 $x \\equiv x_0 (mod \\ m^\\prime)$ $a^\\prime x \\equiv b^\\prime (mod \\ m^\\prime)$ 有解 $x \\equiv x_0b^\\prime +km^\\prime (mod \\ m^\\prime),k=0,\\pm1,\\pm 2 ,\\cdots$ $ax \\equiv b (mod \\ m )$解得 $x \\equiv x_0b^\\prime +wm^\\prime(mod \\ m),w=0,1,2,\\cdots ,gcd(a,m)-1$ 设 $m$ 为正整数，若同余式 $$ x^2 \\equiv a (mod \\ m) ,gcd(a,m)=1 $$ 有解，则称 $a$ 为模 $m$ 的二次剩余，否则称 $a$ 为模 $m$ 的二次非剩余。 对于 $m=2$ ，判断某个数是否为模 $m$ 的二次剩余是平凡的（$x=[1]$）。 在模奇素数 $p$ 的一个既约剩余系中，恰有 $\\frac{p-1}2$ 个模 $p$ 的二次剩余，$\\frac{p-1}2$ 个模 $p$ 的二次非剩余。 设 $p$ 为一个奇素数，$gcd(a,p)=1$ ，$a$ 是模 $p$ 的二次剩余的充要条件是 $$ a^{\\frac{p-1}2 \\equiv 1(mod \\ p)} $$ $a$ 是模 $p$ 的二次非剩余的充要条件是 $$ a^{\\frac{p-1}2 \\equiv -1(mod \\ p)} $$ ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/:1:0","tags":["初等数论"],"title":"信息安全数学基础 第二章 同余","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/"},{"categories":["信息安全"],"content":"中国剩余定理CRT 如果 $m_1,m_2,\\cdots ,m_k$ 是两两互素的正整数，则同余方程组 $$ \\left{ \\begin{align} x \u0026\\equiv a_1 (mod \\ m_1)\\ x \u0026\\equiv a_2 (mod \\ m_2)\\ \u0026\\cdots\\ x \u0026\\equiv a_k (mod \\ m_k)\\ \\end{align} \\right. $$ 对模 $m=m_1m_2 \\cdots m_k$ 有唯一解。 $M_i=\\frac {m}{m_i}=m_1 \\cdots m_{i-1}m_{i+1} \\cdots m_k$ $M_i^ \\prime=M_i^ {-1}(mod \\ m_i)$ 解为 $x \\equiv M_1^\\prime M_1 a_1+M_2^\\prime M_2 a_2+ \\cdots +M_k^\\prime M_k a_k(mod \\ m)$ 如果 $m_1,m_2,\\cdots ,m_k$ 是两两互素的正整数，则同余方程 $$ f(x) \\equiv 0 (mod \\ m) $$ 与同余方程组 $$ \\left{ \\begin{align} x \u0026\\equiv a_1 (mod \\ m_1)\\ x \u0026\\equiv a_2 (mod \\ m_2)\\ \u0026\\cdots\\ x \u0026\\equiv a_k (mod \\ m_k)\\ \\end{align} \\right. $$ 同解 群 $G,H,\\forall g \\in G,h \\in H$ $G \\times H$ 是群 $(g,h) \\in G \\times H,|G \\times H|=|G||H|$ （两个维度） 对于代数运算 $\\circ_G,\\circ_H,\\circ_{G\\times H},(g_1,h_1)\\circ_{G \\times H}(g_2,h_2)=(g_1 \\circ_G g_2,h_1 \\circ_H h_2)$ 设 $N=pq$ ，其中 $p$ 和 $q$ 互质 $\\implies Z_N \\cong Z_p \\times Z_q,Z_N^* \\cong Z_p^* \\times Z_q^*$ $p_1 ,p_2 ,\\cdots, p_k$ 成对互质，即$\\forall i \\neq j ,gcd (p_i,p_j)=1,N=p_1 p_2 \\cdots p_k$$\\implies Z_N \\cong Z_{p_1} \\times Z_{p_2} \\times \\cdots \\times Z_{p_k},Z_N^* \\cong Z_{p_1}^* \\times Z_{p_2}^* \\times \\cdots \\times Z_{p_k}^*$ $x_N \\to (x_p,x_q)$ 是简单的 对于 $(x_p,x_q) \\to x_N$ 已知 $(x_p,x_q)=x_p \\cdot (e_p,0_q)+x_q \\cdot (0_p,e_q),e_p,0_p \\in Z_p,e_q,0_q \\in Z_q$ 只要找到 $x_{N1} \\leftrightarrow (e_p,0_q) , x_{N2} \\leftrightarrow (0_p,e_q)$ ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/:2:0","tags":["初等数论"],"title":"信息安全数学基础 第二章 同余","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/"},{"categories":["信息安全"],"content":"RSA公钥加密 密钥生成 $p,q \\in P$ $n=pq,\\varphi(n)=\\varphi(p)\\varphi(q)=(p-1)(q-1)$ $e\\in Z,gcd(e,\\varphi(n))=1$ $d \\in Z,1\u003cd\u003c\\varphi(n),ed\\equiv 1(mod \\ \\varphi(n))$ 加密 $c=m^e(mod \\ n)$ 解密 $m=c^d(mod \\ n)$ ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/:3:0","tags":["初等数论"],"title":"信息安全数学基础 第二章 同余","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/"},{"categories":["信息安全"],"content":"快速幂 计算 $g^A (mod \\ N)$ 将 $A$ 以 $x$ 进制表示为 $A=A_0x^0+A_1x^1+\\cdots +A_rx^r$ （比如二进制） 通过不断的平方，得到 $g^{x^i}$ $a_0 \\equiv g^{x^0} (mod \\ N)$ $a_1 \\equiv a_0^x \\equiv g^{x^1} (mod \\ N)$ $a_2 \\equiv a_1^x \\equiv g^{x^2} (mod \\ N)$ $\\cdots$ $a_r \\equiv a_{r-1}^x \\equiv g^{x^r} (mod \\ N)$ $g^a \\equiv a_0^{A_0}a_1^{A_1}\\cdots a_r^{A_r} (mod \\ N)$ ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/:4:0","tags":["初等数论"],"title":"信息安全数学基础 第二章 同余","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%90%8C%E4%BD%99/"},{"categories":["信息安全"],"content":"第五章 多项式环 $F$ 是一个域，我们称 $f(x)=a_nx^n+a_{n-1}x^{n-1}+ \\cdots+a_1x+a_0(a_i \\in F,n \\in N)$ 是 $F$ 上的一元多项式 $x$ 未定元 $a_n \\neq 0,a_nx^n$ 为 $f(x)$ 首项 $deg(f(x))=n$ 为 $f(x)$ 次数 首一多项式 $f(x)=1 \\cdot x^n+a_{n-1}x^{n-1}+ \\cdots+a_1x+a_0(a_i \\in F,n \\in N)$ $f(x)=a_0 \\neq 0 \\implies deg(f(x))=0$ 零次多项式 多项式环 $F[x]$ 多项式环运算 加法满足封闭性、结合律、交换律 乘法满足封闭性、结合律、交换律 乘法对加法满足分配律 $f(x)=a_nx^n+a_{n-1}x^{n-1}+ \\cdots+a_1x+a_0(a_i \\in F,n \\in N)$ $g(x)=b_nx^n+b_{n-1}x^{n-1}+ \\cdots+b_1x+b_0(b_i \\in F,n \\in N)$ $f(x)+g(x)=(a_n+b_n)x^n+(a_{n-1}+b_{n-1})x^{n-1}+\\cdots + (a_1+b_1)x+(a_0+b_0)$ $f(x)g(x)=\\sum^{m+n}{s=0}(\\sum{i+j=s}a_ib_j)x^s$ 整环 $F$ ，多项式环 $F[x]\\implies F[x]$ 是整环 零元素 $f(x)=0$ $f(x)=a_nx^n+a_{n-1}x^{n-1}+ \\cdots+a_1x+a_0(a_i \\in F,n \\in N)$ 负元 $-f(x)=-a_nx^n-a_{n-1}x^{n-1}- \\cdots-a_1x-a_0(a_i \\in F,n \\in N)$ 单位元 $f(x)=1$ $F[x]$ 无零因子（由 $F$ 无零因子） 如果 $(f(x))^k|g(x)$ 但 $(f(x))^{k+1}$ 不能整除 $g(x)$ ，则称 $f(x)$ 是 $g(x)$ 的 $k$ 重因式 多项式整除性质，$c \\neq 0 \\in F$ $f(x)|0$ $c|f(x) \\because f(x)=c(c^{-1}f(x))$ $f(x)|g(x) \\implies cf(x)|g(x)$ $f(x)|g(x),g(x)|h(x) \\implies f(x)|h(x)$ $f(x)|g(x),f(x)|h(x) \\implies \\forall u(x),v(x) \\in F[x],f(x)|u(x)g(x)+v(x)h(x)$ $f(x)|g(x),g(x)|f(x) \\implies f(x)=cg(x)$ 首一多项式 $p(x) \\in F[x],deg(p(x)) \\geq 1$，如果 $p(x)$ 在 $F[x]$ 内因式仅有零次多项式 $f(x)=c$ 及 $cp(x)$ ，则称 $p(x)$ 是 $F(x)$ 内的一个不可约多项式，否则称为可约多项式 $GF(2)[x]$ 五次以内的不可约多项式 次数 不可约多项式 0 $1$ 1 $x,x+1$ 2 $x^2+x+1$ 3 $x^3+x^2+1,x^3+x+1$ 4 $x^4+x^3+x^2+x+1,x^4+x^3+1,x^4+x+1$ 5 $x^5+x^3+x^2+x+1,x^5+x^4+x^2+x+1,x^5+x^4+x^3+x+1,$$x^5+x^4+x^3+x^2+1,x^5+x^3+1,x^5+x^2+1$ 因式分解唯一定理 $F[x]$ 上的多项式 $$ f(x)=a_nx^n+a_{n-1}x^{n-1}+ \\cdots+a_1x+a_0(a_i \\in F,n \\in N) $$ 可唯一分解为 $$ f(x)=a_n\\cdot(p_1(x))^{k_1}\\cdot(p_2(x))^{k_2}\\cdot\\ \\cdots\\ \\cdot (p_r(x))^{k_r},(k_1,k_2,\\cdots,k_r\u003e0) $$ 其中 $p_1(x),p_2(x),\\cdots$ 是两两不同的首一不可约多项式。除 $p_1(x),p_2(x),\\cdots$ 的排列次序外，上述分解是唯一的 一个多项式 $f(x)\\in F[x]$ 含有因式 $x-a,a\\in F \\iff f(a)=0$ 首一多项式 $f(x) \\in F[x],a(x),b(x) \\in F[x],a(x)=q_1(x)f(x)+r(x),b(x)=q_2(x)f(x)+r(x) \\iff a(x) \\equiv b(x) \\ mod \\ f(x)$ $a(x) \\equiv b(x)\\ mod \\ f(x) \\iff a(x)-b(x)=g(x)f(x),g(x)\\in F[x]$ $a(x) \\equiv b(x)\\ mod \\ f(x) \\iff f(x)|a(x)-b(x)$ 首一多项式 $f(x) \\in F[x],deg(f(x)) \\geq0 \\implies F[x] \\ mod \\ f(x)$ 构成有单位元交换环，称为多项 式剩余类环 $\\overline{a(x)}+\\overline{b(x)}=\\overline{a(x)+b(x)}$ $\\overline{a(x)}\\overline{b(x)}=\\overline{a(x)b(x)}$ $F[x]$ 的理想为 $I={g(x)f(x)|g(x)\\in F[x]}$ $F[x] \\ mod \\ f(x)$ 是环，是 $F[x]$ 关于 $I$ 构成的商环 $F[x]/f(x)F[x]$ $GF(2)[x]\\ mod\\ (x^2+1)={\\overline0,\\overline1,\\overline{x},\\overline{x+1}}$ 零因子 $x+1$ 首一不可约多项式 $f(x) \\in F[x],deg(f(x)) \\geq0 \\implies F[x] \\ mod \\ f(x)$ 构成域 域 $F$ 上的多项式 $F[x]$ 是主理想整环 ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF/:0:0","tags":["抽象代数"],"title":"信息安全数学基础 第五章 多项式环","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF/"},{"categories":["信息安全"],"content":"第六章 有限域 当 $p$ 是素数时，模 $p$ 剩余类集合构成 $p$ 阶有限域 $GF(p)={\\overline0,\\overline1,\\overline2,\\cdots,\\overline{p-1}}$ $q$ 阶有限域 $GF(q)$ 的所有非零元构成 $q-1$ 阶乘法交换群 $G=GF(q)/{0}$ $o(a)=n$ 是使 $a^n=1$ 的最小正整数 $n$ 阶循环群 $\\lang a \\rangle={a^0,a^1,a^2,\\dots,a^{n-1}}$ $\\forall a \\in G, a^{q-1}=1$ $\\forall a \\in F,a^q=a,a^q-a=0$ $GF(q)={x|x^q-x=0}$ $o(a)=q-1,a$ 称为本原域元素 ，简称本原元 有限域中一定含有本原元 本原元 $a,o(a)=q-1,1 \\leq n \\leq q-1,(n,q-1)=1 \\implies o(a^n)=q-1,a^n$ 也是本原元 $GF(q)$ 中有 $\\varphi(q-1)$ 个本原元 在一个无零因子环 $R$ 里所有非零元的加法阶都相同．当加法阶有限时，它是一个素数 14. 环 $R$ 的加法阶称为特征 $CharR$。当 $R$ 中非零元的加法阶为无穷大时 $CharR=0$ ，当 $R$ 中非零元的加 法阶为某个素数 $p$ 时 $CharR=p$ - **域的特征或者是0，或者是一个素数。**有限域的特征是素数 - $Char(GF(p))=|GF(p)|=p$ 如果一个域 $F$ 不再含有真子集作为 $F$ 的子域，则称 $F$ 为素域 阶为素数的有限域必为素域 在特征为 $p \\in P$ 的域中，子集 ${0,1,2, \\cdots ,p-1}$ 与 $GF(p)={\\overline0,\\overline1,\\overline2,\\cdots,\\overline{p-1}}$ 同构，所以 ${0,1,2, \\cdots ,p-1}$ 构成 $p$ 阶有限域，是素域，且是特征为 $p$ 的域的 $p$ 阶子域 任何 $p \\in P$ 阶域与 $GF(p)$ 同构 $p \\in P$ 阶域的特征为 $p$ 有限域的阶必为其特征之幂。$Char(GF(p^m))=p,o(GF(p^m))=p^m$ 如果 $f(x)$ 是 $GF(p)$ 上的 $m$ 次首一不可约多项式，则 $GF(p)[x]\\ mod \\ f(x)$ 构成 $p^m$ 阶有限域 $GF(p^m)$ 任意 $GF(p^m)$ 有限域都同构 ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%9C%89%E9%99%90%E5%9F%9F/:0:0","tags":["抽象代数"],"title":"信息安全数学基础 第六章 有限域","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%9C%89%E9%99%90%E5%9F%9F/"},{"categories":["信息安全"],"content":"第四章 环与域 环 对 $+$ 交换群 对 $\\cdot$ 满足结合律 $(a\\cdot b)\\cdot c=a\\cdot (b\\cdot c)$ $\\cdot$ 对 $+$ 满足左右分配律 $a\\cdot (b+c)=a\\cdot b+a\\cdot c,(b+c)\\cdot a=b\\cdot a+c\\cdot a$ 环 $R$ 性质，$a,b \\in R ,m,n \\in Z^+,ma=a+a+\\cdots+a,a^m=a \\cdot a\\cdot \\ \\cdots \\ \\cdot a$ $a\\cdot 0=0\\cdot a=0$ $a \\cdot (-b)=(-a)\\cdot b=-(ab)$ $n(a+b)=na+nb$ $m(ab)=(ma)b=a(mb)$ $a^ma^n=a^{(m+n)}$ $(a^m)^n=a^{mn}$ 环中一定有零元素（加法群单位元） $\\forall a \\in R,1_R \\cdot a=a \\cdot 1_R \\implies$ 有单位元环 $1_R$ 单位元 $0_R$ 零元素 $-a$ 负元 $\\exist b \\in R,ab=ba=1,a$ 可逆元 $0_R$ 无逆元 环中并不一定所有的非零元都有逆元，如 $Z$ 乘法可逆元一定不是左、右零因子 $\\forall a,b \\in R, a\\cdot b=b\\cdot a \\implies$ 交换环 全体整数关于数的普通加法和乘法构成一个环，称为整数环 $Z$ 全体有理数（实数、复数）关于数的普通加法和乘法构成一个环，称为有理数环 $Q$ $\\forall [a],[b] \\in Z/mZ,[a]+[b]=[a+b],[a][b]=[ab],Z/mZ$ 为模 $m$ 的剩余类环 $\\exist a,b \\in R,a\\neq 0,b\\neq 0,ab=0 \\implies$ 有零因子环，反之无零因子环 $a$ 左零因子 $b$ 右零因子 $Z,Q,R,C$ 无零因子环 合数 $n,Z_n$ 有零因子环 无零因子环 $R,a,b,c \\in R ,a\\neq 0$ $ab=ac \\implies b=c$ $ba=ca \\implies b=c$ 若一个环里消去律成立 $\\implies$ 无零因子环 $R$ 中非零元的加法阶相等，这个加法阶或者是 $\\infin$ ，或者是个素数 $p$。 环 $R$ 的加法阶称为特征 $CharR$。当 $R$ 中非零元的加法阶为无穷大时 $CharR=0$ ，当 $R$ 中非零元的加 法阶为某个素数 $p$ 时 $CharR=p$ 有单位元、无零因子、交换环 $\\implies$ 整环 有单位元、至少包含一个不等于零的元、每一个不等于零的元有一个逆元 $\\implies$ 除环 无零因子环 非零环 $R,R^*={a\\in R | a \\neq 0},R$ 是除环 $\\iff(R,\\cdot)$ 是群 除环 $R,\\forall a ,b \\in R,a\\neq 0,ax=b,ya=b$ 都有唯一解 至少含有两个元素、无零因子、有限环 $\\implies $ 除环 有单位元、至少包含一个不等于零的元、每一个不等于零的元有一个逆元、交换环 $\\implies$ 域 有限整环是域 $p\\in P \\iff Z_p=Z/pZ$ 是域 环 加法$+$ 乘法$\\cdot$ 环 交换群 结合律 整环 交换群 结合律、单位元、无零因子、交换律 除环 交换群 群：结合律、单位元、非零有逆（必无零因子） 域 交换群 交换群：结合律、单位元、非零有逆（必无零因子）、交换律 环 $R$ ，非空子集 $S$ $\\forall a,b \\in S,a-b \\in S,ab\\in S \\iff S$ 是 $R$ 的子环 $\\forall b \\neq 0 ,a \\in S,a-b \\in S,ab^{-1} \\in S \\iff S$ 是 $R$ 子除环 环 $R$ ，非空子集 $I,\\forall r\\in R, \\forall a,b \\in I,a-b\\in I,ar \\in I,ra \\in I \\iff I \\lhd R,I$ 是 $R$ 的理想 理想一定是子环，反之未必 ${0}$ 和 $R$ 都是理想，分别称之为零理想和单位理想，统称平凡理想 除环仅有平凡理想 环 $(R,+,\\cdot),(R^\\prime ,\\oplus,\\circ)$，映射 $f:R \\to R^\\prime,\\forall a,b \\in R$ $f(a+b)=f(a)\\oplus f(b)$ $f(a \\cdot b)=f(a)\\circ f(b)$ $0_R \\implies 0_{R^\\prime}=f(0_R)$ $f(-a)=\\ominus f(a)$ $\\exist 1_R \\implies 1_{R^\\prime}=f(1_R)$ $S$ 是 $R$ 的子环 $\\implies$ $f(S)$ 是 $R^\\prime =f(R)$ 的子环 $S^\\prime$ 是 $R^\\prime$ 的子环 $\\implies$ $S=f^{-1}(S^\\prime)={a \\in R|f(a)\\in S^\\prime}$ 是 $R$ 的子环 $R$ 有单位元，$c \\in R$ 可逆 $\\implies c^\\prime=f(c)$ 可逆，${c^\\prime}^{-1}=f(c^{-1})$ $R$ 是交换环 $\\implies R^\\prime$ 是交换环 同态 $f$ 的核 $ker(f)=f^{-1}(0_{R^\\prime})$ $ker(f)$ 是 $R$ 加法群的子群 $ker(f)={0_R} \\iff f$ 是单同态 乘法在 $ker(f)$ 封闭 $\\iff ker(f)$ 是子环，是 $R$ 的理想 环 $R,R^\\prime,R \\cong R^\\prime$ $R$ 是整环 $\\iff R^\\prime$ 是整环 $R$ 是除环 $\\iff R^\\prime$ 是除环 $R$ 是域 $\\iff R^\\prime$ 是域 非空子集 $T \\subseteq R ,\\lang T \\rang= \\underset{T \\subseteq I,I\\lhd R}{\\cap}I$ 是 $R$ 中包含 $T$ 的最小理想 特别地，若 $T={a}$ ，则简记主理想 $\\lang T \\rang = \\lang a \\rang$ 称为由 $a$ 生成的主理想 $R$ 是交换环 $, \\lang a \\rang={sa+na| \\forall s \\in R,\\forall n \\in Z}$ $R$ 有单位元 $, \\lang a \\rang={x_1ay_1+\\cdots +x_may_m |\\forall x_i,y_i \\in R,\\forall m \\in N }$ $R$ 是有单位元交换环 $, \\lang a \\rang={ra | \\forall r \\in R}=aR=Ra$ $Z$ 的理想一定是主理想 $\\lang n \\rang$ 是 $\\lang m \\rang$ 的子理想 $\\iff m|n$ 环 $R,I\\lhd R,R/I={x+I|x\\in R},[A]=a+I$ $R/I$ 中乘法为 $[X][Y]=[XY]=xy+I$ $R/I$ 构成环，称为商环（剩余类环） 存在满同态 $\\pi:R \\to R/I$ 环同态基本定理 环 $R,R^\\prime $，同态映射$\\varphi:R \\to R^\\prime,N=ker(\\varphi) \\implies N\\lhd R,R^\\prime \\cong G/N$ $R$ 是有单位元交换环 $,a,b \\in R,I \\lhd R,\\forall ab\\in I,a\\in I$ 或 $b \\in I \\implies I$ 是 $R$ 的素理想 环 $R,M\\lhd R,M \\neq R,\\forall I \\lhd R,M \\supseteq I \\implies M$ 是 $R$ 的极大理想 有单位元交换环 $R$ $M$ 是 $R$ 的极大理想 $\\iff R/M$ 是域 $P$ 是 $R$ 的素理想 $\\iff R/P$ 是整环 对于每一个整环 $R$ ，一定存在一个域 $Q$，使得 $R$ 是 $Q$ 的子环 ","date":"2023-11-03","objectID":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%8E%AF%E4%B8%8E%E5%9F%9F/:0:0","tags":["抽象代数"],"title":"信息安全数学基础 第四章 环与域","uri":"/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%8E%AF%E4%B8%8E%E5%9F%9F/"},{"categories":["算法"],"content":"盾神与格子游戏 ","date":"2023-04-06","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/:0:0","tags":["基础","SG函数","动态规划"],"title":"蓝桥杯 835 盾神与格子游戏","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"题目 问题描述 在盾神很小很小还不会怎样编程的时候，他迷上了一款风靡一时的双人游戏！游戏双方在地上画n个格子，然后在最后一格放上一颗石头。每人每轮可以把石头向前移动1到3格，最后谁把石头移出第一格就赢了。盾神那时候很傻很天真，每次都是随便乱玩，结果每次都会输。。。 盾神今天回想起来，那时候的自己真是弱暴了！！！今天的盾神不仅一眼把这个游戏的必胜方法秒解，还提出了一个进化版：每人每轮不是把石头向前移动1到3格那么简单，而是有m种选择：第i种可以向前移动ai格。其他规则还是和以前一样。那么聪明的你，能告诉盾神，如果双方都采取最优策略，先手第一步该怎样做才可以保证必胜？ 输入格式 第一行为两个数n，m。 第二行m个数，表示ai。 输出格式 如果先手必败，输出“poor dun”，否则输出先手第一步应该向前移动多少格，如果有多种方案，选择移动距离最少的那个。 样例输入 6 3 1 10 100 样例输出 10 样例输入 6 3 1 2 3 样例输出 2 样例输入 6 3 1 1 1 样例输出 poor dun 数据规模和约定 对于20％的数据，ai为从1到m的连续整数。 对于另外30％的数据，n\u003c=20,m\u003c=3。 对于100％的数据，n\u003c=100000,m\u003c=100,0\u003cai\u003c=100000。 ","date":"2023-04-06","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/:1:0","tags":["基础","SG函数","动态规划"],"title":"蓝桥杯 835 盾神与格子游戏","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"题解 ","date":"2023-04-06","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/:2:0","tags":["基础","SG函数","动态规划"],"title":"蓝桥杯 835 盾神与格子游戏","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.StringTokenizer; public class Main { public static int[] choices; public static int[] sgArray; public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine()); int n = Integer.parseInt(stringTokenizer.nextToken()); int m = Integer.parseInt(stringTokenizer.nextToken()); stringTokenizer = new StringTokenizer(bufferedReader.readLine()); sgArray = new int[n + 1]; choices = new int[m]; for (int i = 0; i \u003c m; i++) { choices[i] = Integer.parseInt(stringTokenizer.nextToken()); } Arrays.sort(choices); sgArray[choices[0]] = choices[0]; for (int i = 1; i \u003c n + 1; i++) { for (int j = 0; j \u003c m; j++) { if (i - choices[j] \u003c 0 || sgArray[i - choices[j]] == 0) { sgArray[i] = 1; break; } } } for (int firstStep : choices) { if (n - firstStep \u003c 0 || sgArray[n - firstStep] == 0) { System.out.println(firstStep); return; } } System.out.println(\"poor dun\"); } } ","date":"2023-04-06","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/:3:0","tags":["基础","SG函数","动态规划"],"title":"蓝桥杯 835 盾神与格子游戏","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-835-%E7%9B%BE%E7%A5%9E%E4%B8%8E%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"categories":["算法"],"content":"最大最小公倍数 ","date":"2023-03-23","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/:0:0","tags":["贪心"],"title":"蓝桥杯 2 最大最小公倍数","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"题目 问题描述 已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。 输入格式 输入一个正整数N。 输出格式 输出一个整数，表示你找到的最小公倍数。 样例输入 9 样例输出 504 数据规模与约定 1 \u003c= N \u003c= 106。 ","date":"2023-03-23","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/:1:0","tags":["贪心"],"title":"蓝桥杯 2 最大最小公倍数","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"题解 该题考查的是贪心算法。首先考虑何种情况下可以构造一个比较大的最小公倍数，容易想到当三数互素或其最大公约数较小的时候最小公倍数较大。 考虑N、N-1、N-2，当N为奇数时，三者显然互素。因为三者的因数最大为N-(N-2)=2，而由于N和N-2均为奇数，故其最小公约数为1。 当N为偶数时，比较N*(N-1)*(N-2)/2和N*(N-1)*(N-3)，显然后者较大，但可能存在gcd(N,N-3)=3。 当N有因数3时，比较N*(N-1)*(N-3)/3和(N-1)*(N-2)*(N-3)，显然后者较大，即存在三种情况： N为奇数 out = (long) N * (N - 1) * (N - 2); N为偶数且被3整除 out = (long) (N - 1) * (N - 2) * (N - 3); N为偶数且不被3整除 out = (long) N * (N - 1) * (N - 3); ","date":"2023-03-23","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/:2:0","tags":["贪心"],"title":"蓝桥杯 2 最大最小公倍数","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bufferedReader.readLine()); long out = 0; if (N % 2 == 1) { out = (long) N * (N - 1) * (N - 2); } else { if (N % 3 == 0) out = (long) (N - 1) * (N - 2) * (N - 3); else out = (long) N * (N - 1) * (N - 3); } System.out.println(out); } } ","date":"2023-03-23","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/:3:0","tags":["贪心"],"title":"蓝桥杯 2 最大最小公倍数","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-2-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"categories":["算法"],"content":"K好数 ","date":"2023-03-23","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/:0:0","tags":["动态规划"],"title":"蓝桥杯 3 K好数","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"题目 问题描述 如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。 输入格式 输入包含两个正整数，K和L。 输出格式 输出一个整数，表示答案对1000000007取模后的值。 样例输入 4 2 样例输出 7 数据规模与约定 对于30%的数据，KL \u003c= 106； 对于50%的数据，K \u003c= 16， L \u003c= 10； 对于100%的数据，1 \u003c= K,L \u003c= 100。 ","date":"2023-03-23","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/:1:0","tags":["动态规划"],"title":"蓝桥杯 3 K好数","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"题解 该题可以使用动态规划。使用二维数组dp[L][K]保存计算过程，其中dp[i][j]表示i位K进制数（从第0位开始计）以j开头符合K好数规则的数的个数。 状态转移方程为： $$ dp[i][j]=\\sum ^{k-1}_{k=0} dp[i-1][k]-dp[i-1][j-1]-dp[i-1][j+1] $$ 由样例可知对四进制数01、02、03不看作K好数，即有效的数不能以0开头，所以需要对dp[i][0]做特殊处理。 ","date":"2023-03-23","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/:2:0","tags":["动态规划"],"title":"蓝桥杯 3 K好数","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine()); int K = Integer.parseInt(stringTokenizer.nextToken()); int L = Integer.parseInt(stringTokenizer.nextToken()); int[][] dp = new int[L][K]; for (int i = 0; i \u003c K; i++) { dp[0][i] = 1; } for (int i = 1; i \u003c L; i++) { for (int j = 0; j \u003c K; j++) { for (int k = 0; k \u003c K; k++) { if (Math.abs(j - k) != 1) dp[i][j] = (dp[i][j] + dp[i - 1][k]) % 1000000007; } } } int out = 0; for (int i = 1; i \u003c K; i++) { out = (out + dp[L - 1][i]) % 1000000007; } System.out.println(out); } } ","date":"2023-03-23","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/:3:0","tags":["动态规划"],"title":"蓝桥杯 3 K好数","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"注意 注意循环的起始条件，dp[i][0]不能因为数0ABCDEF……无效就简单赋值为0，因为dp[i+1][2]包含dp[i][0]，此时这个i+1位数是有效的。正确的做法是在计算结果时从dp[L-1][1]开始。 ","date":"2023-03-23","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/:4:0","tags":["动态规划"],"title":"蓝桥杯 3 K好数","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-3-k%E5%A5%BD%E6%95%B0/"},{"categories":["算法"],"content":"完全背包问题 ","date":"2023-03-21","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","tags":["动态规划"],"title":"蓝桥杯 857 完全背包问题","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"题目 问题描述 有一個背包，容量為M。有N種物品，每種物品有其體積Wi與價值Vi。將這些物品的一部分放入背包，每種物品可以放任意多個，要求總體積不超過容量，且總價值最大。 输入格式 第一行為N, M。 之後N行，每行為Wi, Vi。 输出格式 一個數，為最大價值。 样例输入 3 20 15 16 6 6 7 5 样例输出 18 数据规模和约定 N, M\u003c=1000。 ","date":"2023-03-21","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:1:0","tags":["动态规划"],"title":"蓝桥杯 857 完全背包问题","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"题解 可以与01背包问题比较，区别在于01背包每件物品只能放一次，完全背包每件物品可以放多次。 解题思路：通过动态规划，求解局部最优的同时记录，在增加一个物品后更新最优解。 设第i个物品体积为w[i]，价值为v[i]， f[i][j]表示选择前i个物品，背包剩余体积为j时的最优方案，即所选物品的最大权重和。 解法一： 状态转移方程 $$ f[i][j]=max(f[i-1][j-v[i]]+w[i],f[i-1][j]) $$ for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { f[i][j] = f[i - 1][j]; if (v[i] \u003e j) { // 防止数组越界 continue; } for (int k = 0; k * v[i] \u003c= j; k++) { f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); } } } 解法二： 状态转移方程 $$ f[i][j]=max(f[i-1][j-v[i]]+w[i],f[i-1][j]) $$ for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { if (j - w[i] \u003c 0) //剩余容量为j条件下无法再加第i个了 continue; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - w[i]] + v[i]); } } 解法三： 状态转移方程 $$ f[i][j]=max(f[i-1][j-v[i]]+w[i],f[i-1][j]) $$ for(int i = 1 ; i \u003c= n ; i++){ for(int v = w[i]; v \u003c= V ; v++){ // 正向枚举v dp[v] = max(dp[v],dp[v-w[i]] + c[i]); } } 写成一维形式之后和01背包完全相同，唯一的区别在于这里v的枚举顺序是正向枚举，而01背包的一维形式中v必须是逆向枚举。 ","date":"2023-03-21","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:2:0","tags":["动态规划"],"title":"蓝桥杯 857 完全背包问题","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer=new StringTokenizer(bufferedReader.readLine()); int N= Integer.parseInt(stringTokenizer.nextToken()); int M= Integer.parseInt(stringTokenizer.nextToken()); int[][] dp=new int[N+1][M+1]; int[] w=new int[N+1]; int[] v=new int[N+1]; for (int i = 1; i \u003c N+1; i++) { stringTokenizer=new StringTokenizer(bufferedReader.readLine()); w[i]= Integer.parseInt(stringTokenizer.nextToken()); v[i]= Integer.parseInt(stringTokenizer.nextToken()); } for (int i = 1; i \u003c N+1; i++) { for (int j = 0; j \u003c M+1; j++) { if (j-w[i]\u003c0) //剩余容量为j条件下无法再加第i个了 continue; dp[i][j]=Math.max(dp[i-1][j],dp[i][j-w[i]]+v[i]); //比较不放(dp[i-1][j])和放(dp[i][j-w[i]]+v[i])哪一个更优 } } System.out.print(dp[N][M]); } } ","date":"2023-03-21","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:0","tags":["动态规划"],"title":"蓝桥杯 857 完全背包问题","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"注意 三种解法依次优化。 if (v[i] \u003e j) 可以优化到 for (int j = 1; j \u003c= m; j ++ ) 中，优化后为： for (int j = v[i]; j \u003c= m; j ++ ) { } w[] 和 v[]可以优化掉。代码中的v和w数组使用仅限于i状态下，因此，可以定义两个变量，v和w，在for (int i = 1; i \u003c= n; i ++ )中输入即可，优化后： for (int i = 1; i \u003c= n; i++) { int v, w; Scanner scanner = new Scanner(System.in); v = scanner.nextInt(); w = scanner.nextInt(); scanner.nextLine(); } 参考资料 第二讲 完全背包问题 ","date":"2023-03-21","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:4:0","tags":["动态规划"],"title":"蓝桥杯 857 完全背包问题","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-857-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"B君的希望 ","date":"2023-03-16","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:0:0","tags":["最长上升子序列"],"title":"蓝桥杯 839 B君的希望","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"题目 问题描述 你有个同学叫B君，他早听闻祖国河山秀丽，列了一张所有可能爬的山的高度表，因“人往高处走”的说法，所以他希望要爬的山按照表上的顺序，并且爬的每一座山都要比前一座高，爬的山数最多，请贵系的你帮他解决这个问题。(cin,cout很坑) 输入格式 输入第一行为num(1~1000)和maxHeight(1~8848)，代表山的个数和最大高度 输入第二行有num个整数，代表表上每座山的高度height(1~maxHeight) 输出格式 输出只有一个数，为符合要求的最大爬山数 样例输入 10 10 8 6 8 5 9 5 2 7 3 6 3 4 样例输出 3 样例输入 10 20 8 19 9 10 3 3 15 3 10 6 样例输出 4 数据规模和约定 num(1~1000)，maxHeight(1~8848)，height(1~maxHeight)，都是正整数 ","date":"2023-03-16","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:1:0","tags":["最长上升子序列"],"title":"蓝桥杯 839 B君的希望","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"题解 观察代码注释。 思路是记录局部最佳方案的值，再比较是否能在已有的方案上进一步增长递增序列长度。 ","date":"2023-03-16","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:2:0","tags":["最长上升子序列"],"title":"蓝桥杯 839 B君的希望","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer=new StringTokenizer(bufferedReader.readLine()); int num= Integer.parseInt(stringTokenizer.nextToken()); //只需要num，不需要保留maxHeight stringTokenizer=new StringTokenizer(bufferedReader.readLine()); int[] mounts=new int[num]; int[] re=new int[num]; //re[i]记录mounts[0]~mounts[i]的最长递增序列长度 for (int i = 0; i \u003c num; i++) mounts[i] = Integer.parseInt(stringTokenizer.nextToken()); re[0]=1; //可以爬mount[0]本身 int out=1; //目前全局最优为1 for (int i = 1; i \u003c num; i++) { int max=0; //最坏方案为0，同时也是目前的局部最优 for (int j = 0; j \u003c i; j++) { if(mounts[j]\u003cmounts[i]){ //意味着到mounts[j]的方案还可能被优化，即加上mounts[i] max=Math.max(max,re[j]); //判断是否更新目前的最优方案 } } re[i]=max+1; //re[i]包括mounts[i]本身，必然+1 out=Math.max(out,re[i]); //在计算过程中保留全局最优 } System.out.print(out); } } ","date":"2023-03-16","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:3:0","tags":["最长上升子序列"],"title":"蓝桥杯 839 B君的希望","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"注意 可以在计算过程中保留全局最优。 ","date":"2023-03-16","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/:4:0","tags":["最长上升子序列"],"title":"蓝桥杯 839 B君的希望","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-839-b%E5%90%9B%E7%9A%84%E5%B8%8C%E6%9C%9B/"},{"categories":["算法"],"content":"筛法 ","date":"2023-03-11","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/:0:0","tags":["筛法"],"title":"蓝桥杯 964 筛法","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"题目 问题描述 炫炫学了筛法之后，很想用筛法求欧拉函数。他决定求1到N的所有数的欧拉函数值。 输入格式 输入的第一行包含1个整数n,。 输出格式 输出若干行，每行包含一个整数，第i行表示i的欧拉函数值 样例输入 2 样例输出 1 1 数据规模和约定 n\u003c=500000 ","date":"2023-03-11","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/:1:0","tags":["筛法"],"title":"蓝桥杯 964 筛法","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"题解 该题考查素数筛。素数筛有埃氏筛（the Sieve of Eratosthenes，埃拉托色尼筛）和欧拉筛（the Sieve of Euler，也叫线性筛）。可以通过筛出1~N的所有素数来求解欧拉函数。 求欧拉函数数值有公式： $$ \\phi(n)=\\prod^r_{i=1}(\\frac{p_i-1}{p_i}) $$ 其中任何一个大于1的自然数n,如果n不为质数，那么n可以唯一分解成有限个质数的乘积 $$ n=p_1^{k_1}p_2^{k_2}\\dots p_r^{k_r} $$ 根据线性筛同时求解欧拉函数值，可以根据三条性质来求解 $$ 设p为素数，有如下关系：\\ \\phi(p)=p-1\\ p与i互素 \\ \\phi(p \\cdot i)=\\phi(p)\\cdot \\phi(i)\\ p为i的质因数 \\ \\phi(p \\cdot i)=p \\cdot \\phi(i) $$ ","date":"2023-03-11","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/:2:0","tags":["筛法"],"title":"蓝桥杯 964 筛法","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static int[] eulerSet; //eulerSet[i]对应i的欧拉函数值 public static boolean[] isComposite; //如果i为合数，isComposite[i]为true public static int[] primeSet; //存储算出的素数 public static int cnt = 0; //算出的素数个数 public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(bufferedReader.readLine()); eulerSet = new int[n + 1]; primeSet = new int[n]; isComposite = new boolean[n + 1]; getPrime(n); for (int i = 1; i \u003c n + 1; i++) { System.out.println(eulerSet[i]); } } public static void getPrime(int n) { //欧拉筛（线性筛）判断是否为素数，同时记录欧拉函数值 eulerSet[1] = 1; for (int i = 2; i \u003c= n; i++) { if (!isComposite[i]) { //若i为质数 primeSet[cnt] = i; //将质数i记录 cnt++; eulerSet[i] = i - 1; //欧拉函数为i-1 } for (int j = 0; primeSet[j] * i \u003c= n; j++) { isComposite[primeSet[j] * i] = true; if (i % primeSet[j] == 0) { //primeSet[j]为i的最小质因数，同时也为primeSet[j]*i的最小质因数 eulerSet[primeSet[j] * i] = eulerSet[i] * primeSet[j]; break; //算完最小的质因数，后面再算会产生重复 } eulerSet[primeSet[j] * i] = eulerSet[i] * (primeSet[j] - 1); //primeSet[j]不为i的最小质因数，primeSet[j]与i互素 } } } } ","date":"2023-03-11","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/:3:0","tags":["筛法"],"title":"蓝桥杯 964 筛法","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"注意 考虑到时间复杂度，需要使用欧拉筛。 我一开始的思路是先求解1~n的所有素数，再对每一个数做质因数分解，根据公式求每一个数的欧拉函数值，然而超时。故转为在筛选素数的同时计算每一个数的欧拉函数值。 ","date":"2023-03-11","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/:4:0","tags":["筛法"],"title":"蓝桥杯 964 筛法","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-964-%E7%AD%9B%E6%B3%95/"},{"categories":["算法"],"content":"过河马 ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:0:0","tags":["动态规划","递推"],"title":"蓝桥杯 981 过河马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"题目 问题描述 在那个过河卒逃过了马的控制以超级超级多的走法走到了终点之后，这匹马表示它不开心了…… 于是，终于有一天，它也过河了！ 由于过河马积累了许多的怨念，所以这次它过了河之后，再也没有什么东西可以限制它，它可以自由自在的在棋盘上驰骋。一开始，它是在一个n行m列棋盘的左下角（1,1）的位置，它想要走到终点右上角（n，m）的位置。而众所周知，马是要走日子格的。可是这匹马在积累了这么多怨念之后，它再也不想走回头路——也就是说，它只会朝向上的方向跳，不会朝向下的方向跳。 那么，这匹马它也想知道，它想从起点跳到终点，一共有多少种走法呢？ 输入格式 第一行两个数n，m，表示一个n行m列的棋盘，马最初是在左下角（1,1）的位置，终点在右上角（n，m）的位置。 输出格式 输出有一行，一个数表示走法数。由于答案可能很大，所以输出答案除以1000000007所得的余数即可。 样例输入 4 4 样例输出 2 数据规模和约定 n\u003c=100,m\u003c=100 ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:1:0","tags":["动态规划","递推"],"title":"蓝桥杯 981 过河马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"题解 由于题目规定马只能朝上跳，所以不会存在循环的情况，且棋盘第1行易知不可到达。可用动态规划，即棋盘的某一位置(i,j)只能由其下面的四个位置到达。通过二维数组来记录每个位置的走法数，设[i][j]的值为走法数，有如下递推关系： $$ [i][j]=[i-1][j-2]+[i-1][j+2]+[i-2][j-1]+[i-2][j+1] $$ 只要在程序中判断来源的四个位置是否合法即可。 ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:2:0","tags":["动态规划","递推"],"title":"蓝桥杯 981 过河马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stringTokenizer = null; int n, m; try { stringTokenizer = new StringTokenizer(bufferedReader.readLine()); } catch (IOException e) { throw new RuntimeException(e); } n = Integer.parseInt(stringTokenizer.nextToken()); m = Integer.parseInt(stringTokenizer.nextToken()); long[][] dp = new long[n][m]; dp[0][0] = 1; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c m; j++) { if (i - 1 \u003e -1 \u0026\u0026 j - 2 \u003e -1) //i-1\u003cn\u0026\u0026i-1\u003e-1\u0026\u0026j-2\u003e-1\u0026\u0026j-2\u003cm dp[i][j] = (dp[i][j] + dp[i - 1][j - 2]) % 1000000007; if (i - 1 \u003e -1 \u0026\u0026 j + 2 \u003e -1 \u0026\u0026 j + 2 \u003c m) //i-1\u003cn\u0026\u0026i-1\u003e-1\u0026\u0026j+2\u003e-1\u0026\u0026j+2\u003cm dp[i][j] = (dp[i][j] + dp[i - 1][j + 2]) % 1000000007; if (i - 2 \u003e -1 \u0026\u0026 j - 1 \u003e -1) //i-2\u003cn\u0026\u0026i-2\u003e-1\u0026\u0026j-1\u003e-1\u0026\u0026j-1\u003cm dp[i][j] = (dp[i][j] + dp[i - 2][j - 1]) % 1000000007; if (i - 2 \u003e -1 \u0026\u0026 j + 1 \u003c m) //i-2\u003cn\u0026\u0026i-2\u003e-1\u0026\u0026j+1\u003e-1\u0026\u0026j+1\u003cm dp[i][j] = (dp[i][j] + dp[i - 2][j + 1]) % 1000000007; } } System.out.println(dp[n - 1][m - 1] % 1000000007); } } ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:3:0","tags":["动态规划","递推"],"title":"蓝桥杯 981 过河马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"注意 由于n\u003c=100,m\u003c=100，输入较大时结果用int类型会溢出，建议使用long类型，且在运算过程中取余。 ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:4:0","tags":["动态规划","递推"],"title":"蓝桥杯 981 过河马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"拓展 同样是马走日，如果没有限定只能朝上跳，那么无法计算出所有走法了。 算法-ALGO-1001-跳马 ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/:5:0","tags":["动态规划","递推"],"title":"蓝桥杯 981 过河马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-981-%E8%BF%87%E6%B2%B3%E9%A9%AC/"},{"categories":["算法"],"content":"数的潜能 ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:0:0","tags":["数学"],"title":"蓝桥杯 999 数的潜能","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"题目 问题描述 将一个数N分为多个正整数之和，即N=a1+a2+a3+…+ak，定义M=a1a2a3*…*ak为N的潜能。 给定N，求它的潜能M。 由于M可能过大，只需求M对5218取模的余数。 输入格式 输入共一行，为一个正整数N。 输出格式 输出共一行，为N的潜能M对5218取模的余数。 样例输入 10 样例输出 36 数据规模和约定 1\u003c=N\u003c10^18 ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:1:0","tags":["数学"],"title":"蓝桥杯 999 数的潜能","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"题解 该题为找规律题。 先尝试从比较小的数开始分解，得到其最大的分解方法： N 最大的分解方法 1 就是1本身 2 就是2本身 3 就是3本身 4 就是4本身，或者是2+2 5 2+3 6 3+3 7 4+3=2+2+3 8 2+3+3 9 3+3+3 10 2+2+3+3 11 2+3+3+3 12 3+3+3+3 13 2+2+3+3+3 14 2+3+3+3+3 可以发现除去1以后，分解具有如下规律： 尽量3进行分解 如果3分解有余，则用剩余部分用2分解 同时发现若分解成9+9的形式可以减少计算，计算时间更长，但实现更简单，原理同快速幂算法。 可以使用快速幂算法进行幂运算，此处不赘述。 ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:2:0","tags":["数学"],"title":"蓝桥杯 999 数的潜能","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public static void main(String[] args) { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); long N; try { N = Long.parseLong(bufferedReader.readLine()); } catch (IOException e) { throw new RuntimeException(e); } if (N \u003c 4) { System.out.println(N); return; } int rest = (int) (N % 3); int result = 0; if (rest == 0) { N /= 3; result = qpow(3, N, 5218); } else if (rest == 1) { N = (N - 4) / 3; result = (qpow(3, N, 5218) * 4) % 5218; } else { N = (N - 2) / 3; result = (qpow(3, N, 5218) * 2) % 5218; } System.out.println(result); } public static int qpow(long b, long e, int mod) { \\\\快速幂 int result = 1; while (e != 0) { if ((e \u0026 1) == 1) result = (int) ((result * (b % mod)) % mod); b = (b * b) % mod; e \u003e\u003e= 1; } return result; } } ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:3:0","tags":["数学"],"title":"蓝桥杯 999 数的潜能","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"注意 对1~3需要进行特判。 由于输入的数可能比较大，所以应该使用long关键字。 分解后进行累乘时，由于指数可能比较大，推荐使用快速幂，或将数分解为9+9的形式，结果相同。 快速幂函数中推荐每一步都取余，防止数溢出。 ","date":"2023-03-09","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/:4:0","tags":["数学"],"title":"蓝桥杯 999 数的潜能","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-999-%E6%95%B0%E7%9A%84%E6%BD%9C%E8%83%BD/"},{"categories":["算法"],"content":"跳马 ","date":"2023-03-08","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/:0:0","tags":["状态搜索"],"title":"蓝桥杯 1001 跳马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"题目 问题描述 一个8×8的棋盘上有一个马初始位置为(a,b)，他想跳到(c,d)，问是否可以？如果可以，最少要跳几步？ 输入格式 一行四个数字a,b,c,d。 输出格式 如果跳不到，输出-1；否则输出最少跳到的步数。 样例输入 1 1 2 3 样例输出 1 数据规模和约定 0\u003ca,b,c,d≤8且都是整数。 ","date":"2023-03-08","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/:1:0","tags":["状态搜索"],"title":"蓝桥杯 1001 跳马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"题解 使用DFS搜索，退出条件为： 搜索步数大于目前的最小步数 调到目标位置，记录步数 遍历所有结果，每一个可到达位置都走过了（最坏，即不可到达） 可以将一些变量保存为静态变量，而不是在递归函数中声明，也不是通过形参传入，目的是减少内存消耗，同时使方法间可以共享信息。 ","date":"2023-03-08","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/:2:0","tags":["状态搜索"],"title":"蓝桥杯 1001 跳马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static int result = -1; public static int x0, y0, x1, y1; public static int[][] array = new int[9][9]; public static int[][] horse = {% raw %} {{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1}}; {% endraw %} public static void main(String[] args) { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); try { StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine()); x0 = Integer.parseInt(stringTokenizer.nextToken()); y0 = Integer.parseInt(stringTokenizer.nextToken()); x1 = Integer.parseInt(stringTokenizer.nextToken()); y1 = Integer.parseInt(stringTokenizer.nextToken()); } catch (IOException e) { throw new RuntimeException(e); } array[x0][y0] = 1; dfs(x0, y0, 0); System.out.println(result); } public static void dfs(int x, int y, int step) { if (result != -1) if (step \u003e= result) return; if (x == x1 \u0026\u0026 y == y1) { result = step; return; } int xTemp, yTemp; for (int i = 0; i \u003c 8; i++) { xTemp = x + horse[i][0]; yTemp = y + horse[i][1]; if (xTemp \u003e 0 \u0026\u0026 xTemp \u003c= 8 \u0026\u0026 yTemp \u003e 0 \u0026\u0026 yTemp \u003c= 8) { if (array[xTemp][yTemp] == 0) { array[xTemp][yTemp] = 1; dfs(xTemp, yTemp, step + 1); array[xTemp][yTemp] = 0; } else return; } } } } ","date":"2023-03-08","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/:3:0","tags":["状态搜索"],"title":"蓝桥杯 1001 跳马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"注意 需要一个二维数组保存DFS中走过的位置，在递归后恢复为走过的状态。其中起始位置一定是走过的。 一定要剪枝，否则无论输入为何，计算过程中都会将所有可能路径完整计算一遍，肯定超时。 注意该题的棋盘是有范围的，一开始想通过不定方程组来求解，理论上不存在不能到达的位置。但由于该题棋盘有限，该方法不建议使用。 ","date":"2023-03-08","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/:4:0","tags":["状态搜索"],"title":"蓝桥杯 1001 跳马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"拓展 算法-ALGO-981-过河马 ","date":"2023-03-08","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/:5:0","tags":["状态搜索"],"title":"蓝桥杯 1001 跳马","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1001-%E8%B7%B3%E9%A9%AC/"},{"categories":["算法"],"content":"拿金币 ","date":"2023-03-02","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:0:0","tags":["动态规划"],"title":"蓝桥杯 1006 拿金币","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"},{"categories":["算法"],"content":"题目 问题描述 有一个N x N的方格,每一个格子都有一些金币,只要站在格子里就能拿到里面的金币。你站在最左上角的格子里,每次可以从一个格子走到它右边或下边的格子里。请问如何走才能拿到最多的金币。 输入格式 ​ 第一行输入一个正整数n。 ​ 以下n行描述该方格。金币数保证是不超过1000的正整数。 输出格式 最多能拿金币数量。 样例输入 3 1 3 3 2 2 2 3 1 2 样例输出 11 数据规模和约定 ​ n\u003c=1000 ","date":"2023-03-02","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:1:0","tags":["动态规划"],"title":"蓝桥杯 1006 拿金币","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"},{"categories":["算法"],"content":"题解 可以判断此题属于动态规划题。用一个二维数组存储输入，并加以处理即可。由于只能向左或向右，通过计算得到一个新的二维数组，其中a[i][j]表示在此位置的最优路径的各节点权重之和。**可以通过按行从左往右依次遍历原数组，比较每一个元素的左元素和上元素，取二者权重较大的和该元素生成新元素的值。**即 array[i][j] += Math.max(array[i][j - 1], array[i - 1][j]) 最终右下角元素的值就是答案。 ","date":"2023-03-02","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:2:0","tags":["动态规划"],"title":"蓝桥杯 1006 拿金币","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"},{"categories":["算法"],"content":"代码 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); int n=Integer.parseInt(bufferedReader.readLine()); int[][] array=new int[n+1][n+1]; for (int i = 1; i \u003c n+1; i++) { String s =bufferedReader.readLine(); StringTokenizer stringTokenizer = new StringTokenizer(s); for (int j = 1; j \u003c n + 1; j++){ array[i][j]=Integer.parseInt(stringTokenizer.nextToken()); } } for (int i = 1; i \u003c n+1; i++) { for (int j = 1; j \u003c n + 1; j++) { array[i][j] += Math.max(array[i][j - 1], array[i - 1][j]); } } System.out.println(array[n][n]); } } ","date":"2023-03-02","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:3:0","tags":["动态规划"],"title":"蓝桥杯 1006 拿金币","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"},{"categories":["算法"],"content":"注意 小技巧：使用BufferedReader类。一开始我使用Scanner类输入数据，提交显示内存超限。通过查询，发现BufferedReader类在内存使用方面消耗更少，于是用BufferedReader类代替了Scanner类。 Scanner类和BufferedReader类不能混用，猜测是由于缓冲区的原因。一旦使用Scanner类读取输入（我这里是使用Scanner类读取了n的值，BufferedReader类尝试读取其它数据），则BufferedReader类只能读取到新输入的字符串（即无法读取其它数据），导致结果报错。 ","date":"2023-03-02","objectID":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/:4:0","tags":["动态规划"],"title":"蓝桥杯 1006 拿金币","uri":"/%E8%93%9D%E6%A1%A5%E6%9D%AF-1006-%E6%8B%BF%E9%87%91%E5%B8%81/"}]