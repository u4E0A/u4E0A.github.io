# 力扣 1690 石子游戏 VII


# 石子游戏 VII

## 题目

> 石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，**爱丽丝先开始** 。
>
> 有 `n` 块石子排成一排。每个玩家的回合中，可以从行中 **移除** 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 **和** 相等的得分。当没有石头可移除时，得分较高者获胜。
>
> 鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 **减小得分的差值** 。爱丽丝的目标是最大限度地 **扩大得分的差值** 。
>
> 给你一个整数数组 `stones` ，其中 `stones[i]` 表示 **从左边开始** 的第 `i` 个石头的值，如果爱丽丝和鲍勃都 **发挥出最佳水平** ，请返回他们 **得分的差值** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：stones = [5,3,1,4,2]
> 输出：6
> 解释：
> - 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。
> - 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。
> - 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。
> - 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。
> - 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。
> 得分的差值 18 - 12 = 6 。
> ```
>
> **示例 2：**
>
> ```
> 输入：stones = [7,90,5,1,100,10,10,2]
> 输出：122
> ```
>
>  
>
> **提示：**
>
> - `n == stones.length`
> - `2 <= n <= 1000`
> - `1 <= stones[i] <= 1000`

## 题解

### 方法一：记忆化搜索

**思路与算法**

根据题意可知有 $n$ 块石子，游戏的每个回合中，选手可以从行中**移除**最左边的石头或最右边的石头，并获得与该行中剩余石头值之**和**相等的得分。由于先手的 $\text{Bob}$ 一定会输，此时 $\text{Bob}$ 与 $\text{Alice}$ 得分的差值一定小于 $0$；$\text{Alice}$ 一定会赢，此时 $\text{Alice}$ 与 $\text{Bob}$ 得分的差值一定大于 $0$，$\text{Bob}$ 尽力**减小**得分的差值，$\text{Alice}$ 的尽量**扩大**得分的差值，二者的博弈过程即等价于不管是 $\text{Bob}$ 还是 $\text{Alice}$ 都尽可能的**扩大得分**的差值。根据题意可以推出，假设当前石头序列固定，则不管是 $\text{Alice}$ 先手还是 $\text{Bob}$ 先手，二者之间得分的**最大差值**一定是确定的。

假设当前只剩下索引区间 $[i,j]$ 的石头待选择，此时对于该轮选手来说，它的最优解到底是该选最左侧的 $i$ 还是右侧的元素 $j$ 呢？假设当前只剩下 $[s_i,s_{i+1},s_{i+2},s_{i+3},\cdots,s_j]$，且此时轮到 $\text{Bob}$ 选择，$\text{Bob}$ 有两种选择：

- 假设 $\text{Bob}$ 首先拿走的是 $s_i$ ，则其得分为 $\sum_{k=i+1}^{j}$，剩余的元素为  $[s_{i+1},s_{i+2},s_{i+3},\cdots,s_j]$，由于 $\text{Alice}$ 想努力的扩大得分差值，假设 $\text{Alice}$ 在剩余石头序列 $[s_{i+1},s_{i+2},s_{i+3},\cdots,s_j]$ 中游戏的得分与 $\text{Bob}$ 得分最大差值为 $f(i+1,j)$，此时 $\text{Bob}$ 与 $\text{Alice}$ 的得分差值即为 $\sum_{k=i+1}^{j} - f(i+1,j)$

- 假设 $\text{Bob}$ 首先拿走的是 $s_j$ ，则其得分为 $\sum_{k=i}^{j-1}$，剩余的元素为 $[s_{i},s_{i+1},s_{i+2},\cdots,s_{j-1}]$，由于 $\text{Alice}$ 想努力的扩大得分差值，假设 $\text{Alice}$ 在剩余石头序列 $[s_{i},s_{i+1},s_{i+2},\cdots,s_{j-1}]$ 中游戏的得分与 $\text{Bob}$ 得分最大差值为 $f(i,j-1)$，此时 $\text{Bob}$ 与 $\text{Alice}$ 的得分差值即为 $\sum_{k=i}^{j-1} - f(i,j-1)$；
- 此时可以知道序列 $[s_i,s_{i+1},s_{i+2},s_{i+3},\cdots,s_j]$ 中，$\text{Bob}$ 与 $\text{Alice}$ **得分差的最大值** 为 $f(i,j) = \max(\sum_{k=i+1}^{j} - f(i+1,j), \sum_{k=i}^{j-1} - f(i,j-1))$，综上可以得知最大得分差可以理解为此次操作之后，当前选手所收获的价值 - 剩余序列中对手与自己的得分差的最大值。

根据上述推论，我们可以采用自顶向下的记忆化搜索，如要求得区间 $[i,j]$ 得分的最大差值为 $f(i,j)$，此时根据上述的分析需要求出子区间 $[i,j-1]$ 与 $[i+1,j]$ 的最优值即可。由于每次移除石头的得分为区间的累加和，此时我们可以维护序列的前缀和，即可快速求出区间和。

### 方法二：动态规划

**思路与算法**

方法的一的策略还是可以采用自底向上的动态规划，我们可以首先求出区间 $[i,i]$ 的**最大得分差值**，然后不断向外扩展求出 $[i−1,i]$，$[i,i+1]$ 区间的最优解，一直扩展到区间 $[0,n−1]$，此时即可求出最优解返回即可。

## 代码

**方法一：记忆化搜索**

```python
class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        pre = [0]
        for s in stones:
            pre.append(pre[-1] + s)
        
        @cache
        def dfs(i, j):
            if i > j: return 0
            return max(pre[j + 1] - pre[i + 1] - dfs(i + 1, j), pre[j] - pre[i] - dfs(i, j - 1))
        res = dfs(0, len(stones) - 1)
        dfs.cache_clear()
        return res
```

**方法二：动态规划**

```python
class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        pre = [0]
        for s in stones:
            pre.append(pre[-1] + s)
        
        @cache
        def dfs(i, j):
            if i > j: return 0
            return max(pre[j + 1] - pre[i + 1] - dfs(i + 1, j), pre[j] - pre[i] - dfs(i, j - 1))
        res = dfs(0, len(stones) - 1)
        dfs.cache_clear()
        return res
```


